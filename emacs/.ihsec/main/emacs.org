#+TITLE: Luc's Emacs Config
#+PROPERTY: header-args :tangle ~/.ihsec/main/init.el
#+REVEAL_THEME: night
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+OPTIONS: toc:nil num:nil

* What is this?
  This is my main GNU Emacs configuration file. =org-babel-tangle= will
  write the Emacs-Lisp code blocks from it to my =early-init.el= (only
  the code block in [[*Early Init][Early Init]]) and =init.el= (the rest of the
  configuration). I'm currently using =ihsec=, a package for switching
  Emacs configurations easily, so my Emacs files are actually in
  =~/.ihsec/main/= (main is just the name I gave this configuration).

  After running =org-babel-tangle= and loading the generated
  =early-init.el= and =init.el=, you should have a copy of my Emacs
  configuration. I hope you find this helpful to your own Emacs
  configuration. Happy hacking!
* Base setup
** Early Init
   Other than =init.el=, there's =early-init.el=, which is loaded before
   and allows for a quicker startup. *Note:* I'm making it so this
   section specifically is tangled into =early-init.el= and not =init.el=.
   #+begin_src emacs-lisp :tangle ~/.ihsec/main/early-init.el
     (setq package-enable-at-startup nil)
     (setq inhibit-startup-message t)
     (setq inhibit-splash-screen t)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)
     (tool-bar-mode -1)
     (tooltip-mode -1)
     (set-fringe-mode 5)
   #+end_src

** Package Management
   I'm using =straight.el= alongside =use-package= for package management.
   There's a lot of good stuff about these packages, and I definitely
   encourage you to explore their possibilities beyond what you see
   here, but for now: =straight.el= makes package management a lot more
   intuitive and flexible, being able to get specific recipes from
   specific repositories, and managing those as actual
   version-controlled repositories instead of tarballs, like
   =package.el= does. =use-package= provides a very powerful macro for
   loading packages, granting a lot of freedom related to when to
   actually load the package, applying configuration and so
   forth. =straight.el= fortunately integrates with =use-package= out of
   the box.

   [[https://github.com/raxod502/straight.el][straight.el]]

   [[https://www.emacswiki.org/emacs/UsePackage][EmacsWiki - Use Package]]
   #+begin_src emacs-lisp
     (defvar bootstrap-version)
     (let ((bootstrap-file
            (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
           (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
         (with-current-buffer
             (url-retrieve-synchronously
              "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
              'silent 'inhibit-cookies)
           (goto-char (point-max))
           (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))
     ;; Like `use-package-always-ensure', but for `straight.el'. The flag
     ;; `:straight' can be used to set that explicitly, like `:ensure'.
     (setq straight-use-package-by-default t)
     ;; Clone over SSH.
     (setq straight-vc-git-default-protocol 'ssh)
     ;; Install `use-package'
     (straight-use-package 'use-package)
   #+end_src

** Evil & General Setup
   Vim's modal editing, grammar and keybindings are very much pillars
   of my text editing (and now, thanks to Emacs, much
   more). Thankfully, these packages are here to save the day.
*** Evil Mode
    The Extensive Vi Layer itself! Here I load Evil and customizing some
    basic variables. For information on the package I'm using for
    undo-redo actions and setting here as my undo system, see [[*Undo Fu][Undo Fu]].

    [[https://evil.readthedocs.io/en/latest/index.html][Documentation]]
    #+begin_src emacs-lisp
      (use-package evil
        :init
        (setq evil-want-keybinding nil    ;; For playing nice with `evil-collection'
              evil-want-Y-yank-to-eol t   ;; Equivalent to 'map Y y$' in Vim
              evil-symbol-word-search t   ;; * and # will search for symbols, not words.
              evil-want-C-u-scroll t      ;; \
              evil-want-C-u-delete t)     ;; -\ I don't use C-u for the universal argument
        :config
        (evil-mode 1)
        (evil-select-search-module 'evil-search-module 'evil-search)
        (evil-set-undo-system 'undo-fu)) ;; See the Undo Fu section.
    #+end_src

*** Evil Collection
    Brings Evil keybindings to many, many different parts of Emacs,
    usually through a setup function. Saves me a lot of rebinding trouble.

    [[htTps://github.com/emacs-evil/evil-collection][Git repository]]
    #+begin_src emacs-lisp
      (use-package evil-collection
        :after evil
        :custom
        (evil-collection-setup-minibuffer t)   ;; Modal editing in the minibuffer!
        :init
        (evil-collection-init))
    #+end_src

*** General
    The package I use to manage all my custom keybindings. Going forward
    I'm going to configure a lot of those. I find it complements Evil very
    well, being easy to specify in which states and keymaps the bindings
    apply.

    [[https://github.com/noctuid/general.el][Git repository]]

    Here I created a couple definers that I'll use for many
    keybindings going forward. For the sake of organization, I created
    one for global and one for local keybindings, both using =SPC= as a
    prefix.
    #+begin_src emacs-lisp
      (use-package general
        :config
        ;; For global keybindings.
        (general-create-definer luc/leader-def
          :states '(normal visual motion)
          :keymaps 'override
          :prefix "SPC")
        ;; For local keybindings.
        (general-create-definer luc/leader-def-for-keymaps
          :states '(normal visual motion)
          :prefix "SPC"))
    #+end_src

* Editing
** Undo Fu
   My preferred undo system. Works by creating checkpoints on the undo
   actions that keep the functionality linear and sensibly delimited,
   much easier to follow than the default Emacs undo, but also allow
   for unconstrained and non-linear (default) undo/redo, so there's
   still access to all previous states of the file. It also has a
   function to allow it to be limited to a selected region, but I
   haven't tried that out yet.

   [[https://gitlab.com/ideasman42/emacs-undo-fu][Undo Fu]]

   I'm also using =undo-fu-session=, which makes it possible to have a
   persistent change history of files between sessions. The history
   saving is made automatically when writing to the file.

   [[https://gitlab.com/ideasman42/emacs-undo-fu-session][Undo Fu Session]]
   #+begin_src emacs-lisp
     (use-package undo-fu
       :custom
       (undo-fu-ignore-keyboard-quit t)    ;; C-g won't disable the checkpoint...
       :config
       (luc/leader-def
         "u" 'undo-fu-disable-checkpoint)  ;; ...but now this will
       (use-package undo-fu-session
         :config
         (global-undo-fu-session-mode)))
   #+end_src

** Evil Surround
   Makes surrounding pairs (including brackets, quotes) a text object
   to be operated on, be it changing, deleting or adding.

   [[https://github.com/emacs-evil/evil-surround][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-surround
       :config
       (global-evil-surround-mode 1))
   #+end_src

** Evil Commentary
   Commenting becomes an Evil verb to be applied on text.

   [[https://github.com/linktohack/evil-commentary][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-commentary
       :config
       (evil-commentary-mode 1))
   #+end_src

** Evil Numbers & Speeddating
   =evil-numbers= brings the functionality of incrementing and
   decrementing the number at point from Vim's normal mode =C-a= and =C-x=
   commands. =speeddating= is very similar, with functions to increment
   and decrement the date at point in various formats.

   [[https://github.com/juliapath/evil-numbers][Evil Numbers]]

   [[https://github.com/xuchunyang/emacs-speeddating][Speeddating]]
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (use-package speeddating
         :commands (speeddating-increase
                    speeddating-decrease)
         :init
         (general-def
           :states 'normal
           "C-+" 'speeddating-increase
           "C-_" 'speeddating-decrease))
       (use-package evil-numbers
         :commands (evil-numbers/inc-at-pt
                    evil-numbers/dec-at-pt)
         :init
         (setq evil-numbers-pad-default t)
         (general-def
           :states 'normal
           "C-=" 'evil-numbers/inc-at-pt
           "C--" 'evil-numbers/dec-at-pt)))
   #+end_src

** Evil Snipe
   Extends Evil's character search capabilities, adding a new motion
   that allows for two character searching. Think of Evil's =f/F/t/T=
   commands, but you give those a two character long string as a
   search term.

   By default, the inclusive commands (like =f/F=) are bound to =s/S= in
   the normal state (finally some good use for those chords!) and =z/Z=
   as an operator (say, when it's used as the motion for a =c= command),
   while the exclusive commands (like =t/t=) are bound to nothing in the
   normal state and =x/X= as an operator. For now I've settled on
   binding the exclusive commands to =\= and =|= in the normal state.

   On top of that, Snipe has its own versions of =f/F/t/T/;/,= that work
   just like the basic ones but with highlighting for matches and are
   also more customizable (for example, changing the scope of the
   search, which I haven't messed around with yet). Overall a great
   addition to Evil's vocabulary.

   [[https://github.com/hlissner/evil-snipe][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-snipe
       :init
       ;; Keep the repeat motions to ; and ,
       (setq evil-snipe-repeat-keys nil
             evil-snipe-scope 'visible)
       (general-def
         :states 'normal
         :keymaps 'evil-snipe-mode-map
         "\\" 'evil-snipe-x
         "|" 'evil-snipe-X)
       :config
       (evil-snipe-mode 1)
       ;; Use Snipe's versions of f/F/t/T/;/,
       (evil-snipe-override-mode 1))
   #+end_src

** Evil Multi Edit
   Something like multiple cursors, but it actually marks similar
   editing regions that then have changes mirrored across each
   occurrence. It's leveraging the built-in =iedit-mode= and integrating
   it in Evil, in a way that feels very natural no use.

   [[https://github.com/hlissner/evil-multiedit][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-multiedit
       :config
       (general-def
         :states '(normal insert)
         "C-;" 'evil-multiedit-match-all
         "C-k" 'evil-multiedit-match-and-prev
         "C-j" 'evil-multiedit-match-and-next)
       (luc/leader-def
         "ae" 'evil-multiedit-restore)
       (general-def
         :states 'visual
         "R" 'evil-multiedit-match-all)
       (evil-ex-define-cmd "ie[dit]" #'evil-multiedit-ex-match))
   #+end_src

** Evil MC
   Another multiple cursors package, but with different use
   cases. Those honestly doesn't seem that common compared to the use
   cases of =evil-multi-edit=, but I still keep this package around and
   hopefully I can configure it more sometime.

   [[https://github.com/gabesoft/evil-mc][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-mc
       :config
       (global-evil-mc-mode 1))
   #+end_src

** Evil Matchit
   For expanding the use of Evil's =%= operator, matching not only
   brackets, parens or quotes, but also things like HTML tags,
   beginning and end of expressions, and more.

   [[https://github.com/redguardtoo/evil-matchit][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-matchit
       :config
       (global-evil-matchit-mode))
   #+end_src

** Electric Pairs
   Matching pairs are 'electric'. Isn't the easiest to explain, but
   once you see it in action, you'll know what it does. Pretty
   intuitive.
   #+begin_src emacs-lisp
     (use-package elec-pair
       :init
       (defun luc/electric-pair-inhibit (char)
         (if (char-equal char ?<) t
           (electric-pair-default-inhibit char)))
       :hook
       (org-mode . (lambda () (setq-local electric-pair-inhibit-predicate
                                          #'luc/electric-pair-inhibit)))
       :config
       (electric-pair-mode 1))
   #+end_src

** Subword
   The concept of "word" gets a bit more flexible, making it so mixed
   lowercase and uppercase characters delimit its
   "subwords". Generally feels more intuitive, definitely improves
   camelCase navigation.
   #+begin_src emacs-lisp
     (use-package subword
       :config
       (global-subword-mode 1))
   #+end_src

** Indentation Preferences
   I've mostly been a tabs user, but recently those started to feel
   less intuitive to me, so I'm setting spaces as the default for now,
   let's see how that goes. Other than that I've made a keybinding for
   indenting the whole buffer, since I find myself pressing =gg=G= a
   lot.
   #+begin_src emacs-lisp
     (use-package emacs
       :hook
       (fundamental-mode . (lambda () (setq indent-tabs-mode nil)))
       (prog-mode . (lambda () (setq indent-tabs-mode nil)))
       :config
       (setq-default indent-tabs-mode nil)
       (defun luc/evil-indent-whole-buffer ()
         (interactive)
         (evil-with-single-undo
           (save-excursion
             (evil-indent (point-min) (point-max)))))
       (luc/leader-def
         "=" 'luc/evil-indent-whole-buffer))
   #+end_src

** Aggressive Indent
   This will actively prevent you from messing indentation up, hence
   aggressive indent. Can feel /too/ aggressive at times, so I only load
   it when I choose to explicitly.

   [[https://github.com/Malabarba/aggressive-indent-mode][Git repository]]
   #+begin_src emacs-lisp
     (use-package aggressive-indent
       :commands aggressive-indent-mode
       :init
       (luc/leader-def
         "ia" 'aggressive-indent-mode))
   #+end_src

** Hungry Delete
   When deleting whitespace characters, delete all preceding
   whitespace characters.

   [[https://github.com/nflath/hungry-delete][Git repository]]
   #+begin_src emacs-lisp
     (use-package hungry-delete
       :init
       (setq hungry-delete-join-reluctantly t)
       (luc/leader-def
         "ih" 'hungry-delete-mode)
       :config
       (global-hungry-delete-mode))
   #+end_src

** Delete trailing whitespace before saving
   #+begin_src emacs-lisp
     (use-package emacs
       :hook
       (before-save . delete-trailing-whitespace))
   #+end_src

** Keyboard Macros
   Since Evil macro commands don't play that nicely with Emacs default
   ones (like =edit-last-kbd-macro=, for example, that doesn't affect
   the register where the macro was recorded in), I'm interested in
   creating a setup where I can take advantage of all Emacs has to
   offer concerning keyboard macros, and for that I'm really changing
   the way I think about them coming from Vim - no more saving macros
   to registers and "executing" them back. It actually doesn't feel as
   much of a loss to me, since I can still access the =kmacro-ring= or
   name macros if I need to have access to multiple of them at the
   same time. It's all experimental, I'll see what sorts of problems
   or new ideas come up as I go.

*** Custom functions
    #+begin_src emacs-lisp
      (use-package emacs
        :config
        (defun luc/kmacro-start-or-end-macro (arg)
          "Start defining macro or, if already doing that, end macro."
          (interactive "P")
          (if (or defining-kbd-macro executing-kbd-macro)
              (kmacro-end-macro arg)
            (kmacro-start-macro arg)))
        (defun luc/append-to-last-kbd-macro ()
          "`kmacro-start-macro' prefixed with 'C-u C-u'."
          (interactive)
          (kmacro-start-macro '(16)))
        (defun luc/kmacro-call-macro-single-undo (count)
          "`kmacro-call-macro' as a single evil undo step."
          (interactive "p")
          (evil-with-single-undo
            (kmacro-call-macro count t)))
        (defun luc/consult-kmacro-single-undo (arg)
          "`consult-kmacro' as a single evil undo step."
          (interactive "p")
          (evil-with-single-undo
            (consult-kmacro arg))))
    #+end_src

*** Keybindings
    #+begin_src emacs-lisp
      (use-package emacs
        :config
        (general-unbind
          :states 'normal
          "q"
          "@")
        (general-def
          :states 'normal
          "q" 'luc/kmacro-start-or-end-macro
          "Q" 'luc/append-to-last-kbd-macro
          "@@" 'luc/kmacro-call-macro-single-undo
          "@e" 'edit-last-kbd-macro
          "@k" 'luc/consult-kmacro-single-undo
          "@a" 'kmacro-add-counter)
        (luc/leader-def
          "gn" 'name-last-kbd-macro
          "gq" 'insert-kbd-macro)
        (general-def
          :states 'insert
          "C-q" 'kmacro-insert-counter))
    #+end_src

* Minibuffer & Completion
** Basic minibuffer commands
   Emacs minibuffer commands I use all the time, including an
   alternative keybinding for =execute-extended-command=.
   #+begin_src emacs-lisp
     (use-package emacs
       :init
       (general-def
         :keymaps 'minibuffer-local-map
         :states 'normal
         "<escape>" 'minibuffer-keyboard-quit)
       (luc/leader-def
         "SPC" 'execute-extended-command
         "f" 'find-file
         "d" 'dired))
   #+end_src

** Consult
   A collection of commands based on the =completing-read= function that
   substitute built-in functions such as =imenu= and brings new
   functionality and integration through commands like =consult-find=.

   [[https://github.com/minad/consult][Git repository]]
   #+begin_src emacs-lisp
     (use-package consult
       :hook
       ;; Use `consult-completion-in-region' if Vertico is enabled.
       (vertico-mode . (lambda ()
                         (setq completion-in-region-function
                               (if vertico-mode
                                   #'consult-completion-in-region
                                 #'completion--in-region))))
       :init
       ;; I use `fd' instead of `find'.
       (setq consult-find-command "fd --color=never --hidden ARG OPTS"
             consult-ripgrep-args "rg --null --hidden --line-buffered --color=never --max-columns=1000 --path-separator /   --smart-case --no-heading --line-number .")
       (luc/leader-def
         "b" 'consult-buffer
         "l" 'consult-line
         "r" 'consult-recent-file
         "af" 'consult-find
         "ag" 'consult-ripgrep
         "gi" 'consult-imenu
         "go" 'consult-outline
         "gf" 'consult-focus-lines)
       :config
       ;; Loading previews only when explicitly choosing to with a
       ;; keybinding. Significantly improves speed of these commands,
       ;; specially ones that use external programs such as `grep'.
       (consult-customize
        consult-ripgrep consult-git-grep consult-grep
        consult-bookmark consult-recent-file consult-xref
        consult-project-buffer consult-bookmark
        :preview-key (kbd "C-o")))
   #+end_src

** Vertico
   A completion UI that aims to have full compatibility with built-in
   Emacs completion commands. This stability really shines through,
   making it pretty easy to configure and maintain and integrate with
   other packages.

   [[https://github.com/minad/vertico][Git repository]]
   #+begin_src emacs-lisp
     (use-package vertico
       :init
       (setq enable-recursive-minibuffers t)
       (setq vertico-cycle t)
       (general-def
         :keymaps 'vertico-map
         :states 'insert
         "C-k" 'vertico-previous
         "C-j" 'vertico-next
         "C-l" 'vertico-exit)
       (general-def
         :keymaps 'vertico-map
         :states 'normal
         "k" 'vertico-previous
         "j" 'vertico-next
         "l" 'vertico-exit)
       (vertico-mode 1))
   #+end_src

** Marginalia
   Adds useful annotations to minibuffer selection candidates, such as
   the first line of function docstrings, value of a variable or
   permission details of a file, for example.

   [[https://github.com/minad/marginalia][Git repository]]
   #+begin_src emacs-lisp
     (use-package marginalia
       :init
       (marginalia-mode 1))
   #+end_src

** Orderless
   A completion style that allows for very flexible matching,
   specially out of order (components "file" and "find" in this order
   would still match =find-file=, for example). It's also customizable
   through the use of different matching styles (regular expressions,
   literals, prefixes...) and dispatchers, functions that can change
   the matching style and its behavior on the fly.

   The most interesting component for me though, is the
   separator. Here I'm using the "basic" completion by default, and it
   would only fallback to orderless in case there's no match. But if I
   want to jump straight into orderless, I can simply add the
   separator. When using =vertico=, this isn't that necessary since
   typing spaces there will do the same thing. The real power comes
   from using this with =corfu= (in the next section) to have completion
   in the buffer, while leveraging orderless for all its power.

   [[https://github.com/oantolin/orderless][Git repository]]
   #+begin_src emacs-lisp
     (use-package orderless
       :init
       (defun luc/orderless-start-with-regexp-dispatcher (pattern _index _total)
         (when (string-suffix-p "+" pattern)
           `(orderless-regexp . ,(substring (concat "^" pattern) 0 -1))))

       (setq completion-styles '(basic orderless)
             completion-category-defaults nil
             completion-category-overrides '((file (styles . (partial-completion)))))
       (setq orderless-component-separator "[ |]"
             orderless-matching-styles '(orderless-literal orderless-prefixes)
             orderless-style-dispatchers '(luc/orderless-start-with-regexp-dispatcher)))
   #+end_src

** Corfu
   A package for completion.  As opposed to my previous choice,
   =company=, =corfu= is made to be very minimal in its own functionality,
   and can be expanded with other packages. I feel it's also faster,
   and the customization options make it fit in with my style of
   editing better.

   [[https://github.com/minad/corfu][Git repository]]

*** Base configuration
    #+begin_src emacs-lisp
      (use-package corfu
        :custom
        (corfu-cycle t)
        (corfu-auto t)
        (corfu-auto-prefix 1)
        (corfu-auto-delay 0)
        (corfu-separator ?\|)
        (corfu-quit-at-boundary 'separator)
        (corfu-quit-no-match 'separator)
        (corfu-preview-current nil)
        (corfu-preselect-first t)
        (corfu-on-exact-match nil)
        (corfu-echo-documentation t)
        :init
        (setq completion-cycle-threshold nil
              tab-always-indent 'complete)
        (luc/leader-def
          "ic" 'corfu-mode)
        (general-def
          :keymaps 'corfu-map
          :states 'insert
          "C-l" 'corfu-insert
          "C-n" 'evil-complete-next
          "C-p" 'evil-complete-previous
          "C-SPC" 'corfu-insert-separator)
        (general-unbind
          :keymaps 'corfu-map
          "TAB"
          "<tab>"
          "RET"
          "<return>"))
    #+end_src

*** Extending
    Using =pcmpl-args= to expand shell command completion capabilities,
    =corfu-doc= to show documentation in a little frame (like
    =company-box=), =kind-icon= for icons, and =cape= for more completion
    functions.

    [[https://github.com/JonWaltman/pcmpl-args.el][pcmpl-args.el]] |[[https://github.com/galeo/corfu-doc][corfu-doc]] | [[https://github.com/jdtsmith/kind-icon][kind-icon]] | [[https://github.com/minad/cape][Cape]] |

    #+begin_src emacs-lisp
      (use-package corfu
        :init
        (use-package pcmpl-args)
        (use-package corfu-doc
          :hook
          (corfu-mode . corfu-doc-mode)
          :init
          (general-def
            :keymaps 'corfu-map
            :states 'insert
            "M-p" 'corfu-doc-scroll-up
            "M-n" 'corfu-doc-scroll-down))
        (defun corfu-enable-in-minibuffer ()
          "Enable Corfu in the minibuffer if `completion-at-point' is bound."
          (when (where-is-internal #'completion-at-point (list (current-local-map)))
            (corfu-mode 1)))
        (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)
        (global-corfu-mode)
        :config
        (use-package kind-icon
          :init
          (setq kind-icon-default-face 'corfu-default)
          :config
          (use-package cape
            :init
            (setq cape-dabbrev-min-length 1)
            (general-def
              :states 'insert
              "C-x C-l" 'cape-line
              "C-x C-f" 'cape-file
              "C-x C-]" 'cape-symbol
              "C-x C-p" 'cape-dabbrev
              "C-x C-n" 'cape-dabbrev
              "C-x C-h" 'cape-history)
            :init
            (add-to-list 'completion-at-point-functions #'cape-dabbrev)
            (add-to-list 'completion-at-point-functions #'cape-file)
            (add-to-list 'completion-at-point-functions #'cape-history)
            (add-to-list 'completion-at-point-functions #'cape-ispell))
          (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)))
    #+end_src

** Minibuffer History
   Saving minibuffer histories and additional variables, along some
   keybindings for easy navigation.
   #+begin_src emacs-lisp
     (use-package savehist
       :init
       (general-def
         :keymaps 'minibuffer-local-map
         :states 'insert
         "C-p" 'previous-history-element
         "C-n" 'next-history-element)
       :config
       (setq history-length 250)
       (setq history-delete-duplicates t)
       (setq savehist-additional-variables '(register-alist kmacro-ring))
       (savehist-mode 1))
   #+end_src

** Fasd
   [[https://github.com/clvv/fasd][fasd]] is a command line utility that keeps track of visited files
   and directories and ranks them based on how frequently and how
   recently you've been there. When I learned about it I really liked
   the idea, but most of my file browsing is done in Emacs, of course,
   so it alone wouldn't cut it. Fortunately there is an Emacs package
   for it!

   I didn't like everything about the package by default though, since
   it would always prompt me to select from a list, which isn't as
   slick as just typing a small query and jumping straight to what I
   want, so I made a fork of it. The main different is just that, it
   will prompt for a query and take the first result =fasd= provides. If
   a list is desired, simply pass the new argument =LIST= as =t=.

   [[https://github.com/emacsmirror/fasd][Base emacs-fasd Git repository]]

   [[https://github.com/lucasminah/fasd][My fork]]
   #+begin_src emacs-lisp
     (use-package fasd
       :straight (fasd :type git :host github :repo "emacsmirror/fasd"
                       :fork (:type git :repo "lucasminah/fasd"))
       :init
       (defun luc/fasd-find-select ()
         "`fasd-find-file' promps for selection from list of results."
         (interactive)
         (fasd-find-file nil nil t))
       (luc/leader-def
         "z" 'fasd-find-file
         "Z" 'luc/fasd-find-select)
       (global-fasd-mode 1))
   #+end_src

* Interface & Interactions
** Theme, Modeline & Default Font
   Trying out some Doom themes and the Doom modeline. Looking pretty
   good.

   [[https://github.com/hlissner/emacs-doom-themes][Doom themes]]

   [[https://github.com/seagle0128/doom-modeline][Doom modeline]]
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (column-number-mode 1)
       (use-package modus-themes
         :init
         (setq modus-themes-mode-line 'borderless
               modus-themes-region 'bg-only
               modus-themes-completions nil
               modus-themes-bold-constructs t
               modus-themes-slanted-constructs t
               modus-themes-paren-match 'intense-bold
               modus-themes-syntax nil
               modus-themes-headings '((t . rainbow))
               modus-themes-org-blocks 'gray-background
               modus-themes-scale-headings t))
       (set-face-attribute 'font-lock-comment-face nil :italic t)
       (set-face-attribute 'font-lock-builtin-face nil :italic t)
       (set-face-attribute 'font-lock-keyword-face nil :bold t)
       (set-face-attribute 'font-lock-constant-face nil :bold t)
       (set-face-attribute 'font-lock-type-face nil :bold t)
       (use-package doom-themes
         :custom
         (doom-themes-enable-italic t)
         (doom-themes-enable-bold t)
         :config
         (setq doom-ayu-dark-brighter-comments t
               doom-ayu-dark-comment-bg nil)
         (load-theme 'doom-ayu-dark t))
       (use-package doom-modeline
         :custom
         (doom-modeline-buffer-encoding nil)
         (doom-modeline-window-width-limit 154)
         (doom-modeline-icon t)
         (doom-modeline-height 25)
         :init
         (doom-modeline-mode 1))
       ;; Making this the default font for this and future frames
       (add-to-list 'default-frame-alist '(font . "UbuntuMonoNerdFont-13")))
   #+end_src

** Solaire Mode
   For differentiating between "real" file editing buffers from
   "unreal" popups, terminals and the like, by making the background
   brighter or darker in a very aesthetically pleasing way.
   For some reason it didn't load properly when using =emacsclient -c=,
   so I'm using this little =server-after-make-frame= hack to get it to
   work.

   [[https://github.com/hlissner/emacs-solaire-mode][Git repository]]
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (use-package solaire-mode
         :defer t
         :init
         (luc/leader-def
           "io" 'solaire-mode))
       :hook
       (server-after-make-frame . (lambda ()
                                    (when (not (bound-and-true-p solaire-global-mode))
                                      (progn
                                        (solaire-global-mode +1)
                                        (add-to-list
                                         'solaire-mode-themes-to-face-swap
                                         'doom-dracula)
                                        (solaire-mode-swap-faces-maybe)
                                        (when (string-equal (buffer-name) "*dashboard*")
                                          (revert-buffer)))))))
   #+end_src

** (Non) Blinking Cursor
   Disable cursor blinking. I find it kind of distracting.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (blink-cursor-mode 0))
   #+end_src

** Hide Mode Line
   Sometimes I just need to clean the screen that bit more by hiding
   the modeline. Thankfully, this package provides a minor mode for
   that, so I can toggle it pretty easily.

   [[https://github.com/hlissner/emacs-hide-mode-line][Git repository]]
   #+begin_src emacs-lisp
     (use-package hide-mode-line
       :commands (hide-mode-line-mode
                  global-hide-mode-line-mode)
       :init
       (luc/leader-def
         "ib" 'hide-mode-line-mode
         "iB" 'global-hide-mode-line-mode))
   #+end_src

** Prettify Symbols
   For pretty looking symbols, such as =>==, =<==, =lambda=, etc. It depends
   on the major mode.)
   #+begin_src emacs-lisp
     (use-package emacs
       :hook
       (prog-mode . prettify-symbols-mode)
       (prog-mode . luc/set-my-pretty-symbols)
       :config
       (defun luc/set-my-pretty-symbols ()
         (add-to-list 'prettify-symbols-alist '("function" . ?ƒ))))
   #+end_src

** Beacon
   Highlights the cursor when jumping around with it.

   [[https://github.com/Malabarba/beacon][Git repository]]
   #+begin_src emacs-lisp
     (use-package beacon
       ;; :init
       ;; (beacon-mode 1)
       :config
       (luc/leader-def
         "ij" 'beacon-mode))
   #+end_src

** TTY Faces
   Here I change some face attributes for when using =emacs[client] [-nw|-t|--tty]=.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/tty-set-face-attributes (&optional frame)
         "If the created frame is in a tty, set these face attributes."
         (unless (display-graphic-p frame)
           (set-face-attribute 'hl-line frame :reverse-video t)
           ;; Use terminal's background.
           (set-face-background 'default "unspecified-bg" frame)))
       (add-to-list 'after-make-frame-functions 'luc/tty-set-face-attributes))
   #+end_src

** Dashboard
   A nice starting buffer for Emacs.

   [[https://github.com/emacs-dashboard/emacs-dashboard][Git repository]]
   #+begin_src emacs-lisp
     (use-package dashboard
       :init
       (use-package all-the-icons)
       :config
       (dashboard-setup-startup-hook)
       (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
       :custom
       (dashboard-center-content t)
       (dashboard-banner-logo-title "Welcome to Luc's Emacs!")
       (dashboard-set-heading-icons t)
       (dashboard-set-file-icons t)
       (dashboard-set-navigator t)
       (dashboard-set-footer nil)
       (dashboard-items '((bookmarks . 10)
                          (recents  . 20)))
       (dashboard-navigator-buttons
        `(((,(all-the-icons-octicon "mark-github" :height 1.1 :v-adjust 0.0)
            "Homepage"
            "Browse homepage"
            (lambda (&rest _) (browse-url "https://github.com/")))))))
   #+end_src

** Bookmarks
   A keybinding for accessing =consult-bookmark=. It can be used for
   setting and jumping to bookmarks so, pretty useful.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq bookmark-file "~/.ihsec/main/bookmarks")
       (luc/leader-def
         "ab" 'consult-bookmark))
   #+end_src

** Rainbow Identifiers
   Color codes text symbols. I find this functionality to really fit
   for the way I like navigating and interacting with code, especially
   for recognizing variables.

   [[https://github.com/Fanael/rainbow-identifiers][Git repository]]
   #+begin_src emacs-lisp
     (use-package rainbow-identifiers
       :hook
       (prog-mode . rainbow-identifiers-mode)
       :config
       (luc/leader-def
         "it" 'rainbow-identifiers-mode))
   #+end_src

** Rainbow Delimiters
   Bracket pairs have matching colors.

   [[https://github.com/Fanael/rainbow-delimiters][Git repository]]
   #+begin_src emacs-lisp
     (use-package rainbow-delimiters
       :hook
       (prog-mode . rainbow-delimiters-mode))
   #+end_src

** Rainbow Mode
   Hex codes in text have their background colored.

   [[https://github.com/emacsmirror/rainbow-mode][Git repository]]
   #+begin_src emacs-lisp
     (use-package rainbow-mode
       :hook (prog-mode
              conf-mode
              fundamental-mode
              org-mode)
       :init
       (luc/leader-def
         "ir" 'rainbow-mode))
   #+end_src

** Show Paren Mode
   When the cursor is on a paren, highlight its match.
   #+begin_src emacs-lisp
     (use-package emacs
       :hook
       (prog-mode . show-paren-mode)
       :init
       (setq show-paren-delay 0))
   #+end_src

** Whitespace Mode
   For showing whitespace in the buffer.
   #+begin_src emacs-lisp
     (use-package emacs
       :init
       (luc/leader-def
         "iw" 'whitespace-mode))
   #+end_src

** Help
   Emacs is great at discoverability. Here I set keybindings for help
   ("describe") commands, and load the =helpful= package for better help
   buffers.

   [[https://github.com/Wilfred/helpful][Git repository]]
   #+begin_src emacs-lisp
     (use-package helpful
       :config
       (luc/leader-def
         "hh" 'helpful-at-point
         "hm" 'describe-mode
         "hk" 'helpful-key
         "hv" 'helpful-variable
         "hf" 'helpful-function
         "hF" 'helpful-callable
         "hc" 'helpful-command))
   #+end_src

** Debug on Error
   Hopefully helps getting a backtrace to the cause of errors, or just
   getting rid of freezing from =error on process filter=.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/toggle-debug-on-error ()
         "Toggles the local value of `debug-on-error'"
         (interactive)
         (if (eq debug-on-error t)
             (setq-local debug-on-error nil)
           (setq-local debug-on-error t))))
   #+end_src

** Y/N Prompts
   Please, ask me "y/n" instead of "yes or no".
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defalias 'yes-or-no-p 'y-or-n-p))
   #+end_src

** Finding and reloading configuration
   I visit this file and reload =init.el= quite a lot.  Only makes sense
   to make a couple keybindings for that.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/config-find ()
         "Navigates to my Emacs configuration Org file."
         (interactive)
         (find-file "~/dotfiles/emacs/.ihsec/main/emacs.org"))

       (luc/leader-def
         "ce" 'luc/config-find)

       (defun luc/config-reload ()
         "Reloads init.el"
         (interactive)
         (load-file "~/.emacs.d/init.el"))

       (luc/leader-def
         "cr" 'luc/config-reload))
   #+end_src

** Relative Line Numbers
   Display absolute number for current line, relative number for other
   lines.
   #+begin_src emacs-lisp
     (use-package display-line-numbers
       :config
       (setq display-line-numbers-type 'relative)
       (luc/leader-def
         "in" 'display-line-numbers-mode))
   #+end_src

** Highlight Current Line
   #+begin_src emacs-lisp
     (use-package hl-line
       :commands hl-line-mode
       :init
       (luc/leader-def
         "il" 'hl-line-mode)
       :hook
       (prog-mode . hl-line-mode)
       (conf-mode . hl-line-mode))
   #+end_src

** Highlight Search
   Search matches will remain highlighted until disabled with this
   keybinding.
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (luc/leader-def
         "ih" 'evil-ex-nohighlight))
   #+end_src

** Evil Show Registers
   Keybinding for quickly getting Evil register values.
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (luc/leader-def
         "gr" 'evil-show-registers))
   #+end_src

** Backup & Auto-Save
   Backup files essentially keep previous versions of a file,
   different saved stages it has been. =undo-fu-session= seems to be
   taking care of that for me, but still, I thought I'd at least
   configure the backup files so they don't clutter directories and I
   have more control over them.

   As for auto-save files, they are created automatically after a
   certain number of inputs to the buffer or seconds passed without
   any changes, so they keep unsaved versions of the visited file so
   they can be recovered in the event of a crash - definitely very
   important.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       ;; Backup
       (setq make-backup-files t
             backup-directory-alist `(("." . "~/.emacs.d/backup-files/"))
             backup-by-copying t
             delete-old-versions t
             version-control t
             kept-old-versions 2
             kept-new-versions 6)
       (defun luc/diff-backup-this-file ()
         "Call `diff-backup' with the current file."
         (interactive)
         (diff-backup (buffer-file-name)))
       ;; Auto-Save
       (setq auto-save-default t
             auto-save-timeout 20
             auto-save-interval 200)
       ;; Keybindings
       (general-def
         :states 'normal
         "gb" 'luc/diff-backup-this-file
         "gr" 'revert-buffer
         "gR" 'recover-this-file)
       (luc/leader-def
         "ar" 'recover-session))
   #+end_src

** Fcitx
   [[https://fcitx-im.org/wiki/Fcitx_5][Fcitx]] is the input method framework I use for managing different
   keyboard layouts and language specific input. This package provides
   automatic disabling of the Fcitx input method (and possibly
   others - check final section in the repo's README) in certain
   contexts where it doesn't make sense to use them. For me, when I
   use it to type in Japanese, it's not really useful to have Fcitx
   enabled in the normal state, for example - just makes all
   keybindings unusable, since none of them use Japanese
   characters. All of its functionalities are well explained in the
   repo.

   [[https://github.com/cute-jumper/fcitx.el][Git repository]]
   #+begin_src emacs-lisp
     (use-package fcitx
       :init
       (fcitx-aggressive-setup)
       (setq fcitx-use-dbus t)
       :config
       (fcitx-evil-turn-on))
   #+end_src

* Windows & Buffers
** Basic keybindings
   Creating comfortable keybindings for common buffer/window related
   commands. Some other relevant keybindings (such as for
   =consult-buffer=) were set in "Minibuffer & Completion".
   #+begin_src emacs-lisp
     (luc/leader-def
       "w" 'save-buffer
       "k" 'kill-current-buffer
       "q" 'delete-window
       "eo" 'delete-other-windows
       "ev" 'split-window-horizontally
       "es" 'split-window-vertically
       "en" 'switch-to-next-buffer
       "ep" 'switch-to-prev-buffer
       "eb" 'ibuffer)
   #+end_src

** Evil Split
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq evil-split-window-below t)
       (setq evil-vsplit-window-right t))
   #+end_src

** Winner
   Undo and redo for window actions. I use this a lot when I need to
   have only one window open for a moment, and then want the layout I
   had before back.
   #+begin_src emacs-lisp
     (use-package winner
       :hook (after-init . winner-mode)
       :config
       (luc/leader-def
         "eu" 'winner-undo
         "er" 'winner-redo))
   #+end_src

** Popper
   Package for managing popup buffers - toggling their visibility and
   cycling between them, mainly. Extremely useful to keep from
   cluttering frames with many windows opening transient buffers. I
   plan to add more configuration to configure the placement of
   windows, including popups, with other packages sometime.

   [[https://github.com/karthink/popper][Git repository]]
   #+begin_src emacs-lisp
     (use-package popper
       :init
       (setq
        popper-mode-line '(:eval (propertize " POP " 'face 'mode-line-emphasis))
        popper-display-control t
        popper-reference-buffers '(compilation-mode
                                   comint-mode
                                   Man-mode
                                   eshell-mode
                                   helpful-mode
                                   occur-mode
                                   shell-mode
                                   term-mode
                                   treemacs-mode
                                   vterm-mode
                                   "^\\*Messages\\*"
                                   "^\\*Org Src"
                                   "^\\*Warnings\\*"
                                   "^\\*Backtrace\\*"
                                   "^\\*evil-registers\\*"
                                   "^\\*Apropos\\*"
                                   "^\\*Completions\\*"
                                   "^\\*Compile-Log\\*"
                                   "\\*Shell Command Output\\*"
                                   "\\*Async Shell Command\\*"
                                   "\\*Shell Command\\*"
                                   "[Oo]utput\\*"))
       (popper-mode t)
       :config
       (general-def
         :keymaps 'override
         :states '(insert normal visual emacs motion)
         "M-;" 'popper-toggle-latest
         "M-," 'popper-cycle
         "M-." 'popper-toggle-type))
   #+end_src

** Scrolling
   I want my cursor to only move the screen one line at a time when on
   the edges.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq auto-window-hscroll nil
             auto-window-vscroll nil
             scroll-step 1
             scroll-conservatively 101
             scroll-down-aggressively 0
             scroll-up-aggressively 0))
   #+end_src

** Better visual line navigation
   I always thought the visual line motion commands felt a bit clunky
   by default on Evil. Fortunately, =evil-better-visual-line= makes
   those work flawlessly.

   I'm not currently using =evil-better-visual-line-on= by default
   because I don't want to create discrepancies in behavior relating
   to line movement. Those could be very minor though, will probably
   try it out sometime.
   #+begin_src emacs-lisp
     (use-package evil-better-visual-line
       :commands (evil-better-visual-line-next-line
                  evil-better-visual-line-previous-line)
       :config
       (general-def
         :states 'normal
         "gj" 'evil-better-visual-line-next-line
         "gk" 'evil-better-visual-line-previous-line))
   #+end_src

** Beginning and end of line
   Some Vim bindings that always mildly annoyed me were =0/$= and
   =^/g_=. Moving to the beginning and end of line or first and last
   non-blank character in the line are very useful motions, yet their
   bindings are not that comfortable to hit. Thankfully I can easily
   remap those here.
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (general-def
         :keymaps 'override
         :states 'normal
         "gh" 'evil-beginning-of-line
         "gH" 'evil-first-non-blank
         "gl" 'evil-end-of-line
         "gL" 'evil-last-non-blank))
   #+end_src

** Moving to last line in buffer
   In =evil-mode=, Vim's =G= key is associated with the motion
   =evil-goto-line=, which calls Emacs's =end-of-buffer= when without
   arguments (a line number, in this case). The problem is that
   =end-of-buffer= actually goes beyond what I'd expect, placing the
   cursor after the last newline character, in the beginning of a line
   that isn't really there. I'd prefer it to move to the last actually
   existing line.

   Thankfully, I found someone with an [[https://emacs.stackexchange.com/a/31649][answer]] in Stack Exchange that
   suits me just right. I simply have to add an advice to
   =end-of-buffer=.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/beginning-of-this-or-previous-line (&rest _)
         (beginning-of-line (and (looking-at-p "^$") 0)))
       (advice-add #'end-of-buffer :after #'luc/beginning-of-this-or-previous-line))
   #+end_src

** Occur
   Get a buffer with lines from the current buffer that match the
   expression given. That buffer can even become editable, like
   =wdired=!
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (luc/leader-def
         "gu" 'occur))
   #+end_src

** Avy
   Lots of jumping commands for moving quickly and precisely. In this
   case I'm using Evil's versions of Avy commands so they act as Evil
   motions.

   Evil's =z= bindings do a lot related to outline closing and opening,
   but I feel =outline-cycle= bound to =TAB= is all I need, so I'm willing
   to use some of these keybindings for =avy= motions - they're very
   powerful so I want them pretty easy to hit.
   #+begin_src emacs-lisp
     (use-package evil
       :init
       (general-unbind
         :states 'normal
         "zw"
         "zs"
         "zk"
         "zl"
         "zj"
         "zc"
         "zx")
       (general-def
         :states 'normal
         "zw" 'evil-avy-goto-word-or-subword-1
         "zs" 'evil-avy-goto-symbol-1
         "zk" 'evil-avy-goto-line-above
         "zl" 'evil-avy-goto-line
         "zj" 'evil-avy-goto-line-below
         "zc" 'evil-avy-goto-char-2
         "zx" 'evil-avy-goto-char))
   #+end_src

** Scratch buffers
   Creation of scratch buffers for the major mode of the current
   buffer.

   [[https://codeberg.org/emacs-weirdware/scratch][Git repository]]
   #+begin_src emacs-lisp
     (use-package scratch
       :config
       (luc/leader-def
         "gh" 'scratch))
   #+end_src

* Applications & Utilities
** Equake
   A package for creating a Quake style drop-down terminal that runs
   inside of Emacs, with some additional functionality for managing
   multiple terminal buffers of different types. Haven't configured it
   much, but it comes in handy, even in unexpected ways, like opening
   =mpdel= in it and using it as a drop-down playlist editor!

   [[https://github.com/emacsmirror/equake][Git repository]]
   #+begin_src emacs-lisp
     (use-package dash
       :config
       (use-package equake
         :config
         ;; prevent accidental frame closure:
         (advice-add #'save-buffers-kill-terminal :before-while #'equake-kill-emacs-advice)
         (setq equake-default-shell 'vterm)
         (setq equake-available-shells
               '("shell"
                 "vterm"
                 "rash"
                 "eshell"))))
   #+end_src

** MPDel
   Experimenting with this [[https://www.musicpd.org/][MPD]] client that runs in Emacs. I usually
   use [[https://github.com/ncmpcpp/ncmpcpp][NCMPCPP]], but I'm curious about how Emacs could make the music
   client experience better. I already have global keybindings in my
   window manager for managing toggling the playing/paused state,
   going forwards and backwards in the playlist, controlling volume,
   etc. So this should be used mostly just for searching and playlist
   management.
*** Setup
    I've made some changes to the source code of =libmpdel= and =mpdel= to
    accommodate certain needs of mine, so I'm loading these packages
    from my forks. Briefly, the changes to =mpdel= pertain to changing
    the playlist view, and the changes to =libmpdel= to:
    - Use the =albumartist= tag instead of =artist= - just more useful for me most of the time, and makes it more intuitive for navigating from artist -> album -> song, since the album's contents won't be affected by which artist you selected before.
    - Use =search= and =searchadd= commands instead of =find= and =findadd= - fixes albums appearing empty when opened, which I believe is because =find= commands, when receive an empty string, look for files with tags equal to that content, in this case, empty, while =search= commands treat the empty string as a wildcard.

    [[https://github.com/mpdel/mpdel][Base MPDel repository]]

    [[https://github.com/lucasminah/libmpdel][My fork of libmpdel]]

    [[https://github.com/lucasminah/mpdel][My fork of mpdel]]
    #+begin_src emacs-lisp
      (use-package libmpdel
        :straight (libmpdel :type git :host github :repo "mpdel/libmpdel"
                            :fork (:host github :repo "lucasminah/libmpdel"))
        :config
        (use-package mpdel
          :straight (mpdel :type git :host github :repo "mpdel/mpdel"
                           :fork (:host github :repo "lucasminah/mpdel"))
          :commands mpdel-playlist-open
          :hook
          (mpdel-tablist-mode . turn-off-evil-snipe-mode)
          (mpdel-tablist-mode . hide-mode-line-mode)
          :init
          (evil-collection-mpdel-setup)))
    #+end_src

*** Custom Functions
    #+begin_src emacs-lisp
      (use-package emacs
        :config
        (defun luc/mpdel-consult-search-albums ()
          (interactive)
          (progn
            (unless (get-buffer "*mpdel-All albums*")
              (mpdel-core-open-albums))
            (switch-to-buffer "*mpdel-All albums*")
            (beginning-of-buffer)
            (consult-line)
            (tablist-find-entry)))
        (defun luc/mpdel-consult-search-artists ()
          (interactive)
          (progn
            (unless (get-buffer "*mpdel-All artists*")
              (mpdel-core-open-artists))
            (switch-to-buffer "*mpdel-All artists*")
            (beginning-of-buffer)
            (consult-line)
            (tablist-find-entry))))
    #+end_src

*** Keybindings
    #+begin_src emacs-lisp
      (use-package mpdel
        :init
        (general-def
          :keymaps 'mpdel-tablist-mode-map
          :states 'normal
          "l" 'tablist-find-entry
          "h" 'mpdel-song-quit-window
          "=" 'mpdel-core-volume-increase
          "J" 'mpdel-playlist-move-down
          "K" 'mpdel-playlist-move-up
          "c" 'mpdel-song-open
          "m" 'tablist-mark-forward
          "u" 'tablist-unmark-forward
          "t" 'tablist-toggle-marks
          "gu" 'libmpdel-database-update
          "gp" 'mpdel-playlist-open
          "gP" 'mpdel-playlist-open-stored-playlist
          "or" 'mpdel-core-open-artists
          "sr" 'luc/mpdel-consult-search-artists
          "ol" 'mpdel-core-open-albums
          "sl" 'luc/mpdel-consult-search-albums)
        (luc/leader-def
          "mp" 'mpdel-playlist-open))
    #+end_src

*** Aesthetics
    #+begin_src emacs-lisp
      (use-package mpdel
        :hook
        (mpdel-tablist-mode . hl-line-mode)
        (mpdel-tablist-mode . display-line-numbers-mode)
        :init
        (set-face-attribute 'mpdel-tablist-song-name-face nil
                            :inherit 'font-lock-string-face)
        (set-face-attribute 'mpdel-tablist-track-face nil
                            :inherit 'font-lock-constant-face)
        (set-face-attribute 'mpdel-tablist-album-face nil
                            :inherit 'font-lock-builtin-face)
        (set-face-attribute 'mpdel-tablist-artist-face nil
                            :inherit 'font-lock-builtin-face)
        (set-face-attribute 'mpdel-tablist-date-face nil
                            :inherit 'font-lock-constant-face)
        (set-face-attribute 'mpdel-playlist-current-song-face nil
                            :weight 'bold))
    #+end_src

** Denote
   A package for managing notes, using a very interesting naming
   convention that makes marking and finding notes pretty easy. I'm
   mainly using it to keep a journal.

   [[https://github.com/protesilaos/denote][Git repository]]
   #+begin_src emacs-lisp
     (use-package denote
       :straight (:type git :host github :repo "protesilaos/denote")
       :init
       (require 'denote-dired)
       (setq denote-directory (expand-file-name "~/notes")
             denote-file-type nil ;; Use Org Mode for note files.
             denote-front-matter-date-format 'org-timestamp
             denote-known-keywords '("journal" "random")
             denote-dired-directories (list denote-directory
                                            (thread-last
                                                denote-directory
                                              (expand-file-name "journal"))))
       (defun luc/denote-journal ()
         (interactive)
         (let ((denote-directory (thread-last
                                     denote-directory
                                   (expand-file-name "journal"))))
           (denote
            (format-time-string "%A %e %B %Y" (time-add nil (-  (* 24 (* 60 60)))))
            (denote--keywords-prompt))))
       (luc/leader-def
         "cj" 'luc/denote-journal
         "cn" 'denote)
       :hook
       (dired-mode . denote-dired-mode-in-directories))
   #+end_src

** Imenu
   Jump to points of interest in the buffer.
   #+begin_src emacs-lisp
     (use-package imenu
       :commands (imenu consult-imenu)
       :init
       (luc/leader-def
         "im" 'consult-imenu))
   #+end_src

** Origami
   Package for folding/unfolding regions of text. I found it works better than =outline-minor-mode=.

   [[https://github.com/gregsexton/origami.el][Git repository]]
   #+begin_src emacs-lisp
     (use-package origami
       :hook
       (prog-mode . origami-mode)
       :config
       (general-def
         :keymaps 'origami-mode-map
         :states 'normal
         "<tab>" 'origami-toggle-node
         "<backtab>" 'origami-toggle-all-nodes))
   #+end_src

** Dired
   I use =dired= for basically all my file management. Very versatile
   and powerful.
*** Preferences & Keybindings
    #+begin_src emacs-lisp
      (use-package dired
        :straight (:type built-in)
        :custom
        (delete-by-moving-to-trash t)
        (dired-listing-switches "-al --group-directories-first")
        (dired-isearch-filenames 'dwim)        ;; I-search only matches filenames if cursor is on
                                               ;;   filename column.
        (dired-dwim-target t)                  ;; Deduces where to copy/move files, works great on
                                               ;;   split windows
        :hook
        (dired-mode . dired-hide-details-mode) ;; Don't show full details by default - toggle with
                                               ;;   open paren
        (dired-mode . hl-line-mode)
        :init
        (general-def
          :keymaps 'dired-mode-map
          :states 'normal
          "h" 'dired-up-directory              ;; \
          "l" 'dired-find-file                 ;; -\ Quick navigation
          "q" 'kill-current-buffer))           ;; For keeping Dired buffers from cluttering.
    #+end_src

*** Trashed
    For managing the trash can.

    [[https://github.com/shingo256/trashed][Git repository]]
    #+begin_src emacs-lisp
      (use-package trashed
        :after dired
        :commands trashed
        :init
        (general-def
          :states 'normal
          :keymaps 'dired-mode-map
          "gt" 'trashed))
    #+end_src

*** Dired Subtree
    For tree viewing of directories in the style of Org headings. It's
    one of packages from [[https://github.com/Fuco1/dired-hacks][Dired Hacks]].
    #+begin_src emacs-lisp
      (use-package dired-subtree
        :after dired
        :config
        (general-def
          :keymaps 'dired-mode-map
          "<tab>" 'dired-subtree-toggle
          "<backtab>" 'dired-subtree-cycle))
    #+end_src

*** Async
    For managing asynchronous operations.

    [[https://github.com/jwiegley/emacs-async][Git repository]]
    #+begin_src emacs-lisp
      (use-package async
        :config
        (use-package dired-async
          :straight nil
          :after dired
          :config
          (dired-async-mode 1)))
    #+end_src

*** Dired Open
    For opening different file extensions with external programs. Also
    from [[https://github.com/Fuco1/dired-hacks][Dired Hacks]].
    #+begin_src emacs-lisp
      (use-package dired-open
        :after dired
        :init
        (setq dired-open-extensions '(("mkv" . "mpv")
                                      ("webm" . "mpv")
                                      ("avi" . "mpv")
                                      ("mp4" . "mpv"))))
    #+end_src

*** All The Icons Dired
    Pretty symbols!

    [[https://github.com/jtbm37/all-the-icons-dired][Git repository]]
    #+begin_src emacs-lisp
      (use-package all-the-icons-dired
        :after dired
        :hook
        (dired-mode . all-the-icons-dired-mode))
    #+end_src

*** Writable Dired
    Configuration for =wdired-mode=.
    #+begin_src emacs-lisp
      (use-package wdired
        :straight (:type built-in)
        :after dired
        :init
        (setq wdired-allow-to-change-permissions t)
        (setq wdired-create-parent-directories t))
    #+end_src

** Gnus
   Built-in package for managing RSS feeds, news and mail. For now I
   only use it for mail.  I'm using two GMail accounts here, each with
   authentication info in my =.authinfo= file.  In each account it's
   necessary to enable IMAP and either grant access to third party
   apps or create an app password and use that in =.authinfo=. Other
   than that, I have the variables =NAME= and =EMAIL= set in my =.profile=.

   I definitely still have things I want to improve on it, so that's
   coming soon. Either that or giving =mu4e= another try.

   [[https://www.emacswiki.org/emacs/GnusTutorial][EmacsWiki Gnus Tutorial]]
   #+begin_src emacs-lisp
     (use-package gnus
       :commands (gnus
                  compose-mail
                  compose-mail-other-window)
       :config
       (setq gnus-expert-user t)
       (setq gnus-select-method '(nnnil ""))
       (setq gnus-secondary-select-methods '((nnimap "uni"
                                                     (nnimap-address "imap.gmail.com")
                                                     (nnimap-server-port 993)
                                                     (nnimap-stream ssl)
                                                     (nnimap-authinfo-file "~/.authinfo"))
                                             (nnimap "personal"
                                                     (nnimap-address "imap.gmail.com")
                                                     (nnimap-server-port 993)
                                                     (nnimap-stream ssl)
                                                     (nnimap-authinfo-file "~/.authinfo"))))
       (setq message-send-mail-function 'smtpmail-send-it
             smtpmail-default-smtp-server "smtp.gmail.com")
       (luc/leader-def
         "ml" 'gnus
         "mc" 'compose-mail
         "mC" 'compose-mail-other-window))
   #+end_src

** Straight
   Some keybindings for accessing =straight.el= commands. The
   interactive =straight-use-package= now serves as my command to try
   out packages.
   #+begin_src emacs-lisp
     (use-package straight
       :init
       (luc/leader-def
         "ss" 'straight-use-package
         "sp" 'straight-pull-package
         "sP" 'straight-pull-all))
   #+end_src

** Terminal & Shell
*** Shell & shell commands
    I really like using =shell= if I don't need actual terminal
    emulation, because it really is just an Emacs buffer, with all the
    editing power I could want.

    I also want to be able to simply evaluate a command through the
    shell without having to pull up the buffer, so here I make leader
    keybindings for =shell-command= and =async-shell-command=.
    #+begin_src emacs-lisp
      (use-package shell
        :commands (shell shell-command async-shell-command)
        :init
        (luc/leader-def
          "as" 'shell
          "gs" 'shell-command
          "ga" 'async-shell-command))
    #+end_src

*** Vterm
    A very good terminal emulator for using inside Emacs. With
    =evil-collection=, it gets a lot more comfortable to use (still not
    as comfortable as the Emacs buffer that =shell= provides, but more
    comfortable nonetheless), and I especially like that it can toggle
    sending =ESC= to Emacs or the shell.

    [[https://github.com/akermu/emacs-libvterm][Git repository]]
    #+begin_src emacs-lisp
      (use-package vterm
        :init
        (evil-set-initial-state 'vterm-mode 'insert)
        ;; Place cursor in the prompt line when coming back to insert state.
        (advice-add 'evil-collection-vterm-insert :before #'vterm-reset-cursor-point)
        (luc/leader-def
          "at" 'vterm)
        :commands vterm
        :config
        (evil-collection-vterm-setup)
        (general-def
          :keymaps 'vterm-mode-map
          :states 'normal
          "I" 'evil-collection-vterm-insert-line
          "o" 'evil-collection-vterm-insert
          "O" 'evil-collection-vterm-insert
          "C-e" 'evil-scroll-line-down
          "C-y" 'evil-scroll-line-up)
        (general-def
          :keymaps 'vterm-mode-map
          :states 'insert
          "C-h" 'vterm--self-insert
          "C-l" 'vterm--self-insert
          "C-j" 'evil-collection-vterm-toggle-send-escape))
    #+end_src

** Calc
   The built-in calculator. It's actually the most powerful one I've
   used. Comes in pretty handy, for complex or quick calculations.

   #+begin_src emacs-lisp
     (use-package calc
       :config
       (luc/leader-def
         "," 'calc
         "." 'quick-calc))
   #+end_src

** Hydra
   A package for grouping quick bindings together for a particular
   task. It's a lot easier to understand just seeing an example.

   [[https://github.com/abo-abo/hydra][Git repository]]
*** Scaling windows
    Scaling with =[count] C-w [+/-/</>]= doesn't feel very comfortable,
    since I never know exactly how much I want to scale. This hydra
    makes that a lot easier.
    #+begin_src emacs-lisp
      ;; With this, I can press 'SPC es' and then h/j/k/l how many
      ;; times I need to scale the window properly, then 'q' to quit.
      (use-package hydra
        :config
        (defhydra luc/hydra-window-scale ()
          "Scale current window."
          ("h" evil-window-decrease-width "width--")
          ("l" evil-window-increase-width "width++")
          ("j" evil-window-decrease-height "height--")
          ("k" evil-window-increase-height "height++")
          ("q" nil "quit" :exit t))
        (luc/leader-def
          "ec" 'luc/hydra-window-scale/body))
    #+end_src

** Ispell & Flyspell
   =ispell= is a built-in spellchecking package, and =flyspell-mode= is
   used to highlight misspelled words. I had to install =aspell-en=
   (there are different =aspell= packages for other languages, at least
   in the Arch repositories) for it to work properly, but once that's
   done, it's done!
   #+begin_src emacs-lisp
     (use-package flyspell
       :hook
       (outline-mode . flyspell-mode)
       (text-mode . flyspell-mode)
       :config
       (general-def
         :states 'normal
         "z;" 'flyspell-auto-correct-word
         "zp" 'flyspell-auto-correct-previous-word)
       (luc/leader-def
         "is" 'flyspell-buffer
         "if" 'flyspell-mode
         "id" 'ispell-change-dictionary))
   #+end_src

** PDF Tools
   My use for this so far have been simply reading PDF files, and it
   works very well.

   [[https://github.com/politza/pdf-tools][Git repository]]
   #+begin_src emacs-lisp
     (use-package pdf-tools
       :magic ("%PDF" . pdf-view-mode)
       :hook
       (pdf-view-mode . (lambda () (pdf-view-fit-page-to-window)))
       :config
       (pdf-tools-install
        :no-query t))
   #+end_src

** Keycast
   Display key combinations pressed and the command those are bound to
   execute in the modeline. Since I'm using =doom-modeline=, I looked
   for configuration to make it work properly and found this code
   [[https://www.emacswiki.org/emacs/KeyCast][here]].

   [[https://github.com/tarsius/keycast][Git repository]]
   #+begin_src emacs-lisp
     (use-package keycast
       :config
       (define-minor-mode luc/keycast-mode
         "Show current command and its key binding in the mode line (working on doom-modeline)."
         :global t
         (if luc/keycast-mode
             (add-hook 'pre-command-hook 'keycast--update t)
           (remove-hook 'pre-command-hook 'keycast--update)))
       (add-to-list 'global-mode-string '("" mode-line-keycast " "))
       (luc/keycast-mode))
   #+end_src

** Sudo Edit
   For editing files as the super user.
   #+begin_src emacs-lisp
     (use-package sudo-edit
       :commands sudo-edit
       :init
       (luc/leader-def
         "gS" 'sudo-edit))
   #+end_src

* Org Mode
  An amazing organization tool. I'm using it to write this very file,
  which really facilitates checking and updating the configuration,
  but there's a lot more to it as well.

  [[https://orgmode.org/manual/][Org Manual]]
** Preferences
   Changing the look and feel of =org-mode=, for maximum organization
   power.
*** Header Font Sizes
    #+begin_src emacs-lisp
      (use-package org
        :config
        (dolist (face '((org-level-1 . 1.1)
                        (org-level-2 . 1.05)
                        (org-level-3 . 1.0)
                        (org-level-4 . 1.0)
                        (org-level-5 . 1.0)
                        (org-level-6 . 1.0)
                        (org-level-7 . 1.0)
                        (org-level-8 . 1.0)))
          (set-face-attribute (car face) nil :height (cdr face))))
    #+end_src

*** Variable Pitch Mode
    Different font pitches for different contexts.
    #+begin_src emacs-lisp
      (use-package org
        :config
        (defun luc/set-my-org-face-attributes ()
          (set-face-attribute 'fixed-pitch nil :font "UbuntuMono-13")
          (set-face-attribute 'default nil :inherit 'fixed-pitch)
          (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
          (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
          (set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)
          (set-face-attribute 'org-meta-line nil :inherit 'fixed-pitch))
        :hook
        (org-mode . luc/set-my-org-face-attributes)
        (org-mode . variable-pitch-mode))
    #+end_src

*** Ellipsis & Org Bullets
    Header markers are bullets and expansion markers are little
    triangles. A lot cleaner.
    #+begin_src emacs-lisp
      (use-package org
        :config
        (setq org-ellipsis " ▾")
        (use-package
          org-bullets
          :custom
          (org-bullets-bullet-list '("◉" "●" "○" "●" "○" "●" "○"))
          :hook (org-mode . org-bullets-mode)))
    #+end_src

*** Visual Line Mode
    For visual line wrapping at words.
    #+begin_src emacs-lisp
      (use-package org
        :hook (org-mode . visual-line-mode))
    #+end_src

*** Visual Fill Column
    For centering text in the buffer.

    [[https://github.com/joostkremers/visual-fill-column][Git repository]]
    #+begin_src emacs-lisp
      (use-package visual-fill-column
        :init
        (setq visual-fill-column-width 100)
        (setq visual-fill-column-center-text 1)
        :hook
        (org-mode . visual-fill-column-mode))
    #+end_src

*** Variables
    #+begin_src emacs-lisp
      (use-package org
        :init
        ;; For expanding blocks from snippets.
        (require 'org-tempo)
        ;; Headers are folded by default.
        (setq org-startup-folded t)
        ;; Indentation adapts to subtree level.
        (setq org-adapt-indentation t)
        ;; Hide markers for bold, italis, verbatim...
        (setq org-hide-emphasis-markers t))
    #+end_src

*** Display Inline Images
    #+begin_src emacs-lisp
      (use-package org
        :config
        (defun luc/org-show-all-inline-images ()
          (interactive)
          (org-display-inline-images t t)))
    #+end_src

** Evil Org
   More Evil keybindings for Org Mode.

   [[https://github.com/Somelauw/evil-org-mode][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-org
       :after org
       :hook ((org-mode . evil-org-mode)
              (evil-org-mode . (lambda () (evil-org-set-key-theme '(navigation
                                                                    insert))))))
   #+end_src

** Exporting
   Org is pretty easy to export to different formats (by default, =C-c
   C-e= will bring up Org Export Dispatcher with many options). For
   better visualization in HTML (including =reveal.js= presentations),
   these packages really come in handy.

   [[https://github.com/hexmode/ox-reveal][Ox Reveal]]

   [[https://github.com/hniksic/emacs-htmlize][Htmlize]]
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (use-package org
         :init
         (load-library "org-macro"))
       (use-package ox-reveal
         :init
         (setq org-reveal-mathjax t))
       (use-package htmlize
         :commands htmlize-file))
   #+end_src

** Org Agenda
   I use this daily to manage my schedule, check deadlines, remember
   dates and keep track of my daily routine. Thankfully =evil-org= can
   bring more Evil keybindings to it as well.

   There's a keybinding for toggling =log-mode= in the agenda because
   repeated tasks (from the daily routine, for example) only show up
   there when I mark them as =DONE=, along with the timestamp for when
   I completed them.
   #+begin_src emacs-lisp
     (use-package org
       :hook
       (org-agenda-mode . hl-line-mode)
       :config
       (setq org-directory "~/storage/org")
       (setq org-agenda-files '("~/storage/org/agenda"))
       (setq org-agenda-log-mode-items '(closed clock state))
       (use-package evil-org-agenda
         :straight nil
         :config
         (evil-org-agenda-set-keys))
       (general-def
         :states 'motion
         :keymaps 'org-agenda-mode-map
         "w" 'org-save-all-org-buffers
         "l" 'org-agenda-log-mode)
       (luc/leader-def
         "ca" 'org-agenda))
   #+end_src

** Org Capture
   For quickly 'capturing' something in Org files. I mostly use it
   for adding items to the agenda, but have templates for other uses
   as well.
   #+begin_src emacs-lisp
     (use-package org
       :config
       (luc/leader-def
         "cc" 'org-capture)
       (setq org-capture-templates
             '(("d"
                "Task with deadline"
                entry (file+headline "agenda/deadlines.org" "Deadlines")
                "* TODO %^{Task}\nSCHEDULED: %^t DEADLINE: %^t")
               ("t"
                "Task without deadline"
                entry (file+headline "agenda/tasks.org" "Tasks")
                "* TODO %^{Task}\n SCHEDULED: %^t\n%?")
               ;; Saving events and dates as deadlines to get an early
               ;; reminder that they're coming.
               ("e"
                "Event"
                entry (file+headline "agenda/events.org" "Events")
                "* %^{Event}\nDEADLINE: %^T\n")
               ("r"
                "Dates to remember"
                entry (file+headline "agenda/dates.org" "Dates")
                "* %^{Description}\n%DEADLINE: ^t\n")
               ("l"
                "Link"
                entry (file+headline "links.org" "Links")
                "* [[%x][%^{Description}]]\n%U")
               ("i"
                "Idea/thought"
                entry (file+headline "thoughts.org" "Ideas & Thoughts")
                "* %?\n%U"))))
   #+end_src

** Org Babel
   For managing code blocks in Org files.
*** Automatic tangling
    =org-babel-tangle= writes the contents of the source blocks of an
    Org file into a destination file. Since I'm using it to write to
    configuration files, I'd like that function to be called every
    time I save the corresponding Org file.

    Here I make it so =org-babel-tangle= is added to the
    =after-save-hook= on Org files that match my specification. For
    that, I create a variable that holds a list of my Org
    configuration files (so far only this one) and a function to make
    the check.
    #+begin_src emacs-lisp
      (use-package emacs
        :config
        (defvar luc/org-config-dir (expand-file-name "~/dotfiles")
          "Directory containing org files to be tangled to automatically.")

        (defun luc/auto-tangle-config-files ()
          "Tangle the current org file, if in `luc/org-config-dir'."
          (when (member (buffer-file-name)
                        (directory-files-recursively luc/org-config-dir "\.org$"))
            (let ((org-confirm-babel-evaluate nil))
              (org-babel-tangle))))

        (use-package org
          :hook
          (org-mode . (lambda () (add-hook 'after-save-hook #'luc/auto-tangle-config-files)))))
    #+end_src

*** Languages
    Specifying the languages Org Babel should be able to execute and
    get results from in code blocks.
    #+begin_src emacs-lisp
      (use-package org
        :init
        (org-babel-do-load-languages
         'org-babel-load-languages '((python . t)
                                     (shell . t))))
    #+end_src

* Development
  Building a comfy and powerful development environment.
** LSP & DAP Setup
   Language Server and Debug Adapter protocols. These will be used by
   different languages in different ways, which will be configured in
   [[*Languages][Languages]], so this is only a base setup. Fortunately, neither this
   or the specific setups are hard to get working properly. Here I'm
   also installing [[https://www.flycheck.org/][Flycheck]] so I can use it as my syntax checker (in
   place of =flymake=).
*** LSP Mode
    [[https://emacs-lsp.github.io/lsp-mode/][Overview]]
    #+begin_src emacs-lisp
      (use-package lsp-mode
        :commands (lsp lsp-deferred)
        :init
        (setq gc-cons-threshold 100000000)
        (setq read-process-output-max (* 1024 1024))
        (setq lsp-log-io nil)
        (setq lsp-disabled-clients '(emmet-ls))
        (use-package flycheck ;; Syntax checker
          :config
          (use-package consult-flycheck)
          (luc/leader-def-for-keymaps
            :keymaps 'flycheck-mode-map
            "jc" 'consult-flycheck
            "je" 'flycheck-list-errors
            "jp" 'flycheck-previous-error
            "jn" 'flycheck-next-error))
        (luc/leader-def-for-keymaps
          :keymaps 'lsp-mode-map
          "ja" 'lsp-execute-code-action
          "jt" 'treemacs
          "jl" 'lsp-treemacs-errors-list
          "jd" 'lsp-find-declaration
          "jr" 'lsp-rename
          "jf" 'lsp-find-references))
    #+end_src

*** LSP UI
    #+begin_src emacs-lisp
      (use-package lsp-ui
        :after lsp-mode
        :hook
        (lsp-mode . lsp-ui-mode)
        :init
        (setq lsp-ui-sideline-show-code-actions t)
        (setq lsp-ui-sideline-show-symbol t)
        (setq lsp-ui-sideline-show-diagnostics t)
        (luc/leader-def-for-keymaps
          :keymaps 'lsp-mode-map
          "ls" 'lsp-ui-sideline-mode))
    #+end_src

*** DAP Mode
    [[https://github.com/emacs-lsp/dap-mode][Git repository]]
    #+begin_src emacs-lisp
      (use-package dap-mode
        :hook
        ((lsp-mode . dap-mode)
         (dap-mode . dap-ui-mode)))
    #+end_src

** Languages
   Configuring the development environment for different languages
   (mainly with LSP and DAP).
*** Lisps
    I use a package to highlight quoted symbols as well as =lispy= (a
    mode for editing Lisp that plays nice with all the parenthesis)
    with =lispyville= (an additional mode that works with lispy for Evil
    users).
    
    [[https://github.com/Fanael/highlight-quoted][Highlight Quoted]]
    
    [[https://github.com/abo-abo/lispy][Lispy]]
    
    [[https://github.com/noctuid/lispyville][Lispyville]]
    
    #+begin_src emacs-lisp
      (use-package emacs
        :config
        (use-package highlight-quoted
          :hook
          (emacs-lisp-mode . highlight-quoted-mode)
          (lisp-mode . highlight-quoted-mode))
        (use-package lispy
          :hook
          (emacs-lisp-mode . lispy-mode)
          (lisp-mode . lispy-mode)
          :config
          (use-package lispyville
            :hook
            (lispy-mode . lispyville-mode))))
    #+end_src
    
*** C/C++
    Using =clangd=, which is looked for by default. For reference:
    [[https://emacs-lsp.github.io/lsp-mode/page/lsp-clangd/]]
    #+begin_src emacs-lisp
      (use-package cpp
        :hook ((c-mode c++-mode) . lsp-deferred))
    #+end_src
    
*** Python
    Using =mspyls=. For reference:
    https://emacs-lsp.github.io/lsp-python-ms/    
    #+begin_src emacs-lisp
      (use-package lsp-python-ms
        :ensure t
        :init
        (setq lsp-python-ms-auto-install-server t)
        (setq lsp-python-ms-executable
              "~/.emacs.d/.cache/lsp/mspyls/Microsoft.Python.LanguageServer")
        ;; (setq lsp-python-ms-python-executable
        ;;       "/usr/bin/python2")
        ;; (setq doom-modeline-env-python-executable
        ;;       "/usr/bin/python2")
        :hook (python-mode . (lambda ()
                               (require 'lsp-python-ms)
                               (lsp-deferred))))
    #+end_src
    
*** Java
    #+begin_src emacs-lisp
      (use-package lsp-java
        :hook
        (java-mode . lsp))
    #+end_src
    
*** Lua
    #+begin_src emacs-lisp
      (use-package lua-mode
        :after lsp
        :config
        :magic ("%LUA" . lua-mode)
        :hook (lua-mode . lsp-deferred))
    #+end_src
    
** Magit & Forge
   =magit= is an amazingly powerful Git front-end. I hadn't known of it
   before, but =forge= allows for working with Git forges (in my case,
   Github) from inside Emacs. Even more awesome!
   
   [[https://magit.vc/][Magit Website]]
   
   [[https://magit.vc/manual/forge/][Forge Manual]]
   #+begin_src emacs-lisp
     (use-package magit
       :commands (magit-status magit-clone)
       :init
       (luc/leader-def
         "am" 'magit-status
         "ay" 'magit-clone))
       :config
       (use-package forge
         :custom-face
         ;; For correcting error "Invalid face box".
         (forge-topic-label ((t :box (:line-width -1 :style released-button)))))
   #+end_src

