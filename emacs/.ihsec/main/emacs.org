#+TITLE: Luc's Emacs Config
#+PROPERTY: header-args :tangle ~/.ihsec/main/init.el
#+REVEAL_THEME: night
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+OPTIONS: toc:nil num:nil

* What is this?
  This is my main GNU Emacs configuration file. =org-babel-tangle= will
  write the Emacs-Lisp code blocks from it to my =early-init.el= (only
  the code block in [[*Early Init][Early Init]]) and =init.el= (the rest of the
  configuration). I'm currently using =ihsec=, a package for switching
  Emacs configurations easily, so my Emacs files are actually in
  =~/.ihsec/main/= (main is just the name I gave this configuration).
  
  After running =org-babel-tangle= and loading the generated
  =early-init.el= and =init.el=, you should have a copy of my Emacs
  configuration. I hope you find this helpful to your own Emacs
  configuration. Happy hacking!
* Base setup
** Early Init
   Other than =init.el=, there's =early-init.el=, which is loaded before
   and allows for a quicker startup. *Note:* I'm making it so this
   section specifically is tangled into =early-init.el= and not =init.el=.
   #+begin_src emacs-lisp :tangle ~/.ihsec/main/early-init.el
     (setq package-enable-at-startup nil)
     (setq inhibit-startup-message t)
     (setq inhibit-splash-screen t)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)
     (tool-bar-mode -1)
     (tooltip-mode -1)
     (set-fringe-mode 5)
   #+end_src
   
** Package Management
   I'm using =straight.el= alongside =use-package= for package management.
   There's a lot of good stuff about these packages, and I definitely
   encourage you to explore their possibilities beyond what you see
   here, but for now: =straight.el= makes package management a lot more
   intuitive and flexible, being able to get specific recipes from
   specific repositories, and managing those as actual
   version-controlled repositories instead of tarballs, like
   =package.el= does. =use-package= provides a very powerful macro for
   loading packages, granting a lot of freedom related to when to
   actually load the package, applying configuration and so
   forth. =straight.el= fortunately integrates with =use-package= out of
   the box.
   
   [[https://github.com/raxod502/straight.el][straight.el]]
  
   [[https://www.emacswiki.org/emacs/UsePackage][EmacsWiki - Use Package]]
   #+begin_src emacs-lisp
     (defvar bootstrap-version)
     (let ((bootstrap-file
            (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
           (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
         (with-current-buffer
             (url-retrieve-synchronously
              "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
              'silent 'inhibit-cookies)
           (goto-char (point-max))
           (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))
     ;; Like `use-package-always-ensure', but for `straight.el'. The flag
     ;; `:straight' can be used to set that explicitly, like `:ensure'.
     (setq straight-use-package-by-default t)
     ;; Clone over SSH.
     (setq straight-vc-git-default-protocol 'ssh)
     ;; Install `use-package'
     (straight-use-package 'use-package)
   #+end_src
  
** Evil & General Setup
   Vim's modal editing, grammar and keybindings are very much pillars
   of my text editing (and now, thanks to Emacs, much
   more). Thankfully, these packages are here to save the day.
*** Evil Mode
    The Extensive Vi Layer itself! Here I load Evil and customizing some
    basic variables. For information on the package I'm using for
    undo-redo actions and setting here as my undo system, see [[*Undo Fu][Undo Fu]].
  
    [[https://evil.readthedocs.io/en/latest/index.html][Documentation]]
    #+begin_src emacs-lisp
      (use-package evil
        :init
        (setq evil-want-keybinding nil    ;; For playing nice with `evil-collection'
              evil-want-Y-yank-to-eol t   ;; Equivalent to 'map Y y$' in Vim
              evil-symbol-word-search t   ;; * and # will search for symbols, not words.
              evil-want-C-u-scroll t      ;; \
              evil-want-C-u-delete t)     ;; -\ I don't use C-u for the universal argument
        :config
        (evil-mode 1)
        (evil-select-search-module 'evil-search-module 'evil-search)
        (evil-set-undo-system 'undo-fu)) ;; See the Undo Fu section.
    #+end_src

*** Evil Collection
    Brings Evil keybindings to many, many different parts of Emacs,
    usually through a setup function. Saves me a lot of rebinding trouble.
   
    [[htTps://github.com/emacs-evil/evil-collection][Git repository]]
    #+begin_src emacs-lisp
      (use-package evil-collection
        :after evil
        :custom
        (evil-collection-setup-minibuffer t)   ;; Modal editing in the minibuffer!
        :init
        (evil-collection-init))
    #+end_src

*** General
    The package I use to manage all my custom keybindings. Going forward
    I'm going to configure a lot of those. I find it complements Evil very
    well, being easy to specify in which states and keymaps the bindings
    apply.

    [[https://github.com/noctuid/general.el][Git repository]]

    Here I created a couple definers that I'll use for many keybindings
    going forward. For the sake of organization, I created one for global
    and one for local keybindings, both using =SPC= as a prefix.  Other than
    that, I assign the =keyboard-quit= function to =ESC= when in the normal
    state.
    #+begin_src emacs-lisp
      (use-package general
        :config
        ;; For global keybindings.
        (general-create-definer luc/leader-def
          :states '(normal visual motion)
          :keymaps 'override
          :prefix "SPC")
        ;; For local keybindings.
        (general-create-definer luc/leader-def-for-keymaps
          :states '(normal visual motion)
          :prefix "SPC")
        (general-def
          :states 'normal
          :keymaps 'override
          "ESC" 'keyboard-quit))
    #+end_src
    
* Editing
** Undo Fu
   My preferred undo system. Works by creating checkpoints on the undo
   actions that keep the functionality linear and sensibly delimited,
   much easier to follow than the default Emacs undo, but also allow
   for unconstrained and non-linear (default) undo/redo, so there's
   still access to all previous states of the file. It also has a
   function to allow it to be limited to a selected region, but I
   haven't tried that out yet.

   [[https://gitlab.com/ideasman42/emacs-undo-fu][Undo Fu]]

   I'm also using =undo-fu-session=, which makes it possible to have a
   persistent change history of files between sessions. The history
   saving is made automatically when writing to the file.
   
   [[https://gitlab.com/ideasman42/emacs-undo-fu-session][Undo Fu Session]]
   #+begin_src emacs-lisp
     (use-package undo-fu
       :custom
       (undo-fu-ignore-keyboard-quit t)    ;; C-g won't disable the checkpoint...
       :config
       (luc/leader-def
         "u" 'undo-fu-disable-checkpoint)  ;; ...but now this will
       (use-package undo-fu-session
         :config
         (global-undo-fu-session-mode)))
   #+end_src

** Evil Surround
   Makes surrounding pairs (including brackets, quotes) a text object
   to be operated on, be it changing, deleting or adding.

   [[https://github.com/emacs-evil/evil-surround][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-surround
       :config
       (global-evil-surround-mode 1))
   #+end_src

** Evil Commentary
   Commenting becomes an Evil verb to be applied on text.

   [[https://github.com/linktohack/evil-commentary][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-commentary
       :config
       (evil-commentary-mode 1))
   #+end_src

** Evil Numbers & Speeddating
   =evil-numbers= brings the functionality of incrementing and
   decrementing the number at point from Vim's normal mode =C-a= and =C-x=
   commands. =speeddating= is very similar, with functions to increment
   and decrement the date at point in various formats.
   
   [[https://github.com/juliapath/evil-numbers][Evil Numbers]]
   
   [[https://github.com/xuchunyang/emacs-speeddating][Speeddating]]
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (use-package speeddating
         :commands (speeddating-increase
                    speeddating-decrease)
         :init
         (general-def
           :states 'normal
           "C-+" 'speeddating-increase
           "C-_" 'speeddating-decrease))
       (use-package evil-numbers
         :commands (evil-numbers/inc-at-pt
                    evil-numbers/dec-at-pt)
         :init
         (setq evil-numbers-pad-default t)
         (general-def
           :states 'normal
           "C-=" 'evil-numbers/inc-at-pt
           "C--" 'evil-numbers/dec-at-pt)))
   #+end_src
   
** Evil Snipe
   Extends Evil's character search capabilities, adding a new motion
   that allows for two character searching. Think of Evil's =f/F/t/T=
   commands, but you give those a two character long string as a
   search term.
   
   By default, the inclusive commands (like =f/F=) are bound to =s/S= in
   the normal state (finally some good use for those chords!) and =z/Z=
   as an operator (say, when it's used as the motion for a =c= command),
   while the exclusive commands (like =t/t=) are bound to nothing in the
   normal state and =x/X= as an operator. For now I've settled on
   binding the exclusive commands to =\= and =|= in the normal state.
   
   On top of that, Snipe has its own versions of =f/F/t/T/;/,= that work
   just like the basic ones but with highlighting for matches and are
   also more customizable (for example, changing the scope of the
   search, which I haven't messed around with yet). Overall a great
   addition to Evil's vocabulary.
   
   [[https://github.com/hlissner/evil-snipe][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-snipe
       :init
       ;; Keep the repeat motions to ; and ,
       (setq evil-snipe-repeat-keys nil)
       (general-def
         :states 'normal
         :keymaps 'evil-snipe-mode-map
         "\\" 'evil-snipe-x
         "|" 'evil-snipe-X)
       :config
       (evil-snipe-mode 1)
       ;; Use Snipe's versions of f/F/t/T/;/,
       (evil-snipe-override-mode 1))
   #+end_src
   
** Electric Pairs
   Matching pairs are 'electric'. Isn't the easiest to explain, but
   once you see it in action, you'll know what it does. Pretty
   intuitive.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (electric-pair-mode 1))
   #+end_src

** Subword
   The concept of "word" gets a bit more flexible, making it so mixed
   lowercase and uppercase characters delimit its
   "subwords". Generally feels more intuitive, definitely improves
   camelCase navigation.
   #+begin_src emacs-lisp
     (use-package subword
       :config
       (global-subword-mode 1))
   #+end_src

** Indentation Preferences
   I've mostly been a tabs user, but recently those started to feel
   less intuitive to me, so I'm setting spaces as the default for now,
   let's see how that goes. Other than that I've made a keybinding for
   indenting the whole buffer, since I find myself pressing =gg=G= a
   lot.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq-default indent-tabs-mode nil)
       (defun luc/evil-indent-whole-buffer ()
         (interactive)
         (evil-with-single-undo
           (save-excursion
             (evil-indent (point-min) (point-max)))))
       (luc/leader-def
         "=" 'luc/evil-indent-whole-buffer))
   #+end_src
   
** Aggressive Indent
   This will actively prevent you from messing indentation up, hence
   aggressive indent. Can feel /too/ aggressive at times, so I only load
   it when I choose to explicitly.
   
   [[https://github.com/Malabarba/aggressive-indent-mode][Git repository]]
   #+begin_src emacs-lisp
     (use-package aggressive-indent
       :commands aggressive-indent-mode
       :init
       (luc/leader-def
         "ii" 'aggressive-indent-mode))
   #+end_src
   
** Hungry Delete
   When deleting whitespace characters, delete all preceding
   whitespace characters.
   
   [[https://github.com/nflath/hungry-delete][Git repository]]
   #+begin_src emacs-lisp
     (use-package hungry-delete
       :init
       (setq hungry-delete-join-reluctantly t)
       (luc/leader-def
         "ih" 'hungry-delete-mode)
       :config
       (global-hungry-delete-mode))
   #+end_src
   
** Transpose
   A really cool Emacs editing feature for switching around or
   'transposing' text objects.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (general-def
         :states 'normal
         "C-t" 'transpose-words
         "C-q" 'transpose-chars
         "C-l" 'transpose-lines))
   #+end_src
   
** Keyboard Macros
   Since Evil macro commands don't play that nicely with Emacs default
   ones (like =edit-last-kbd-macro=, for example, that doesn't affect
   the register where the macro was recorded in), I'm interested in
   creating a setup where I can take advantage of all Emacs has to
   offer concerning keyboard macros, and for that I'm really changing
   the way I think about them coming from Vim - no more saving macros
   to registers and "executing" them back. It actually doesn't feel as
   much of a loss to me, since I can still access the =kmacro-ring= or
   name macros if I need to have access to multiple of them at the
   same time. It's all experimental, I'll see what sorts of problems
   or new ideas come up as I go.
*** Custom functions
    #+begin_src emacs-lisp
      (use-package emacs
        :config
        (defun luc/kmacro-start-or-end-macro (arg)
          "Start defining macro or, if already doing that, end macro."
          (interactive "P")
          (if (or defining-kbd-macro executing-kbd-macro)
              (kmacro-end-macro arg)
            (kmacro-start-macro arg)))
        (defun luc/append-to-last-kbd-macro ()
          "`kmacro-start-macro' prefixed with 'C-u C-u'."
          (interactive)
          (kmacro-start-macro '(16)))
        (defun luc/kmacro-call-macro-single-undo (count)
          "`kmacro-call-macro' as a single evil undo step."
          (interactive "p")
          (evil-with-single-undo
            (kmacro-call-macro count t)))
        (defun luc/counsel-kmacro-single-undo ()
          "`counsel-kmacro' as a single evil undo step."
          (interactive)
          (evil-with-single-undo
            (counsel-kmacro))))
    #+end_src
   
*** Keybindings
    #+begin_src emacs-lisp
      (use-package emacs
        :config
        (general-unbind
          :states 'normal
          "q"
          "@")
        (general-def
          :states 'normal
          "q" 'luc/kmacro-start-or-end-macro
          "Q" 'luc/append-to-last-kbd-macro
          "@@" 'luc/kmacro-call-macro-single-undo
          "@e" 'edit-last-kbd-macro
          "@k" 'luc/counsel-kmacro-single-undo
          "@a" 'kmacro-add-counter)
        (luc/leader-def
          "gn" 'name-last-kbd-macro
          "gq" 'insert-kbd-macro)
        (general-def
          :states 'insert
          "C-q" 'kmacro-insert-counter))
    #+end_src
    
* Search & Completion
** Ivy, Counsel & Swiper
   As my completion framework, I'm using Ivy. On top of it I'm loading
   Ivy Rich, for getting details on each option for selection. Also
   setting up keybindings for the Counsel versions of commands for
   much better navigability, substituting I-search with =swiper= and
   remapping some keys for better navigation in the
   =ivy-minibuffer-map=.

   I've made a fork of Ivy to make the keys to quit from the Ivy
   action selection list fully customizable. Found someone had pretty
   much the same idea with this [[https://github.com/abo-abo/swiper/pull/2790][PR]], but it's not been merged in months
   now, so a fork will have to do.
   
   [[https://github.com/abo-abo/swiper][Base Ivy repository]]

   [[https://github.com/lucasminah/swiper][My fork]]
   #+begin_src emacs-lisp
     (use-package ivy
       :straight (swiper :type git :host github :repo "abo-abo/swiper"
                         :fork (:host github :repo "lucasminah/swiper"))
       :config
       (ivy-mode 1)
       (use-package counsel
         :straight (counsel :type git :host github :repo "abo-abo/swiper"
                            :fork (:host github :repo "lucasminah/swiper")))
       (use-package ivy-rich
         :hook
         (ivy-mode . ivy-rich-mode))
       (luc/leader-def
         "SPC" 'counsel-M-x
         "r" 'counsel-recentf
         "f" 'counsel-find-file
         "af" 'counsel-fzf
         "d" 'counsel-dired
         "b" 'counsel-switch-buffer
         "B" 'counsel-switch-buffer-other-window
         "ag" 'counsel-rg)
       (general-def
         :states 'normal
         "C-/" 'swiper)
       (general-unbind
         :keymaps 'ivy-minibuffer-map
         "S-SPC")
       (general-def
         :states 'insert
         :keymaps 'ivy-minibuffer-map
         "C-h" 'minibuffer-keyboard-quit
         "C-l" 'ivy-dispatching-done  ;; Access to ivy actions.
         "C-j" 'ivy-next-line
         "C-k" 'ivy-previous-line
         "C-n" 'ivy-next-history-element
         "C-p" 'ivy-previous-history-element)
       (add-to-list 'ivy-read-action-cancel-keys "C-h")
       (general-def
         :states 'normal
         :keymaps 'ivy-minibuffer-map
         "o" 'ivy-dispatching-done
         "j" 'ivy-next-line
         "k" 'ivy-previous-line
         "J" 'ivy-next-history-element
         "K" 'ivy-previous-history-element))
   #+end_src

** Fasd
   [[https://github.com/clvv/fasd][fasd]] is a command line utility that keeps track of visited files
   and directories and ranks them based on how frequently and how
   recently you've been there. When I learned about it I really liked
   the idea, but most of my file browsing is done in Emacs, of course,
   so it alone wouldn't cut it. Fortunately there is an Emacs package
   for it!

   I didn't like everything about the package by default though, since
   it would always prompt me to select from a list, which isn't as
   slick as just typing a small query and jumping straight to what I
   want, so I made a fork of it. The main different is just that, it
   will prompt for a query and take the first result =fasd= provides. If
   a list is desired, simply pass the new argument =LIST= as =t=.

   [[https://github.com/emacsmirror/fasd][Base emacs-fasd Git repository]]

   [[https://github.com/lucasminah/fasd][My fork]]
   #+begin_src emacs-lisp
     (use-package fasd
       :straight (fasd :type git :host github :repo "emacsmirror/fasd"
                       :fork (:type git :repo "lucasminah/fasd"))
       :init
       (defun luc/fasd-find-select ()
         "`fasd-find-file' promps for selection from list of results."
         (interactive)
         (fasd-find-file nil nil t))
       (luc/leader-def
         "z" 'fasd-find-file
         "Z" 'luc/fasd-find-select)
       (global-fasd-mode 1))
   #+end_src
   
** Company
   A great auto-completion package. Alongside it I'm using
   =company-box=, a nice front-end with pretty symbols, pop-up
   documentation and a stable font for the candidates that doesn't
   change with =variable-pitch-mode= (that really doesn't look good).
   
   I do some remapping to make it more comfortable to use, especially
   so it doesn't interfere with Evil's completion commands (=C-n= and
   =C-p=) or any =TAB= commands (jumping, activating snippets,
   indentation...).
   
   [[https://company-mode.github.io/][Company documentation]]
   
   [[https://github.com/sebastiencs/company-box][Company Box]]
   #+begin_src emacs-lisp
     (use-package company
       :init
       (setq company-idle-delay 0
             company-minimum-prefix-length 1
             company-tooltip-idle-delay 0
             company-selection-wrap-around t
             company-abort-on-unique-match nil)
       ;; Modes to disable `company-mode' on.
       (setq company-global-modes '(not vterm-mode))
       (use-package company-box
         :hook
         (company-mode . company-box-mode)
         :init
         (setq company-box-doc-delay 0))
       (global-company-mode 1)
       :config
       (general-unbind
         :keymaps 'company-active-map
         "<tab>"
         "TAB")
       (general-def
         :keymaps 'company-active-map
         "C-l" 'company-complete
         "C-j" 'company-select-next
         "C-k" 'company-select-previous
         "C-n" 'evil-complete-next
         "C-p" 'evil-complete-previous)
       (luc/leader-def
         "ac" 'company-mode))
   #+end_src

** YASnippet
   For expandable snippets - for and while loops, main function
   definition, if statements... Anything you'd like to have easily
   printed out and jump to specific parts of it, customized for the
   current major mode. Pretty easy to change the existing snippets or
   create your own. The package =yasnippet-snippets= contains a bunch
   ready to use.
   
   I'm using it in conjunction with =company= - right now the
   keybindings feel right in both keymaps, but I should test it more
   to make sure. Also gave a keybinding to the =company-yasnippet=
   function, which gives =company= completion for =yasnippet= snippet
   candidates, but that requires further testing and experimentation,
   since so far I've only got it to work when =company= is not active.
   
   [[https://github.com/joaotavora/yasnippet][YASnippet]]
   
   [[https://github.com/AndreaCrotti/yasnippet-snippets][YASnippet Snippets]]
   #+begin_src emacs-lisp
     (use-package yasnippet
       :hook 
       (company-mode . yas-minor-mode)
       :config
       (general-def
         :keymaps 'yas-keymap
         "<tab>" 'yas-next-field-or-maybe-expand
         "<backtab>" 'yas-prev-field)
       (general-def
         :keymaps 'company-mode-map
         :states 'insert
         "C-l" 'company-yasnippet)
       (use-package yasnippet-snippets))
   #+end_src
   
** Evil Search History
   Keybindings for easily accessing history elements in Evil search.
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (general-def
         :keymaps 'evil-ex-search-keymap
         :states 'insert
         "C-n" 'next-history-element
         "C-p" 'previous-history-element)
       (general-def
         :keymaps 'evil-ex-search-keymap
         :states 'normal
         "J" 'next-history-element
         "K" 'previous-history-element))
   #+end_src
   
* Interface & Interactions
** Theme, Modeline & Default Font
   Trying out some Doom themes and the Doom modeline. Looking pretty
   good.
  
   [[https://github.com/hlissner/emacs-doom-themes][Doom themes]]

   [[https://github.com/seagle0128/doom-modeline][Doom modeline]]
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (use-package doom-themes
         :config
         (load-theme 'doom-dracula t))
       (use-package doom-modeline
         :custom
         (doom-modeline-window-width-limit 154)
         (doom-modeline-icon t)
         (doom-modeline-height 30)
         :init
         (doom-modeline-mode 1))
       ;; Making this the default font for this and future frames
       (add-to-list 'default-frame-alist '(font . "UbuntuMono-13")))
   #+end_src

** Hide Mode Line
   Sometimes I just need to clean the screen that bit more by hiding
   the modeline. Thankfully, this package provides a minor mode for
   that, so I can toggle it pretty easily.
   
   [[https://github.com/hlissner/emacs-hide-mode-line][Git repository]]
   #+begin_src emacs-lisp
     (use-package hide-mode-line
       :commands hide-mode-line-mode
       :init
       (luc/leader-def
         "ib" 'hide-mode-line-mode))
   #+end_src
   
** TTY Faces
   Here I change some face attributes for when using =emacs[client] [-nw|-t|--tty]=.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/tty-set-face-attributes (&optional frame)
         "If the created frame is in a tty, set these face attributes."
         (unless (display-graphic-p frame)
           (set-face-attribute 'hl-line frame :reverse-video t)
           ;; Use terminal's background.
           (set-face-background 'default "unspecified-bg" frame)))
       (add-to-list 'after-make-frame-functions 'luc/tty-set-face-attributes))
   #+end_src
   
** Dashboard
   A nice starting buffer for Emacs.
   
   [[https://github.com/emacs-dashboard/emacs-dashboard][Git repository]]
   #+begin_src emacs-lisp
     (use-package dashboard
       :config
       (dashboard-setup-startup-hook)
       (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
       :custom
       (dashboard-center-content t)
       (dashboard-banner-logo-title "Welcome to Luc's Emacs!")
       (dashboard-set-heading-icons t)
       (dashboard-set-file-icons t)
       (dashboard-set-navigator t)
       (dashboard-set-footer nil)
       (dashboard-items '((bookmarks . 10)
                          (recents  . 20)))
       (dashboard-navigator-buttons
        `(((,(all-the-icons-octicon "mark-github" :height 1.1 :v-adjust 0.0)
            "Homepage"
            "Browse homepage"
            (lambda (&rest _) (browse-url "https://github.com/")))))))
   #+end_src
   
** Bookmarks
   A keybinding for accessing =counsel-bookmark=. It can be used for
   setting and jumping to bookmarks so, pretty useful.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq bookmark-file "~/.ihsec/main/bookmarks")
       (luc/leader-def
         "ab" 'counsel-bookmark))
   #+end_src
   
** Rainbow Delimiters
   Bracket pairs have matching colors.
   
   [[https://github.com/Fanael/rainbow-delimiters][Git repository]]
   #+begin_src emacs-lisp
     (use-package rainbow-delimiters
       :hook
       (prog-mode . rainbow-delimiters-mode))
   #+end_src

** Rainbow Mode
   Hex codes in text have their background colored.
   
   [[https://github.com/emacsmirror/rainbow-mode][Git repository]]
   #+begin_src emacs-lisp
     (use-package rainbow-mode
       :hook (prog-mode
              conf-mode
              fundamental-mode
              org-mode)
       :init
       (luc/leader-def
         "ir" 'rainbow-mode))
   #+end_src

** Help
   Emacs is great at discoverability. Here I set keybindings for help
   ("describe") commands, and load the =helpful= package for better help
   buffers.
   
   [[https://github.com/Wilfred/helpful][Git repository]]
   #+begin_src emacs-lisp
     (use-package helpful
       :custom
       (counsel-describe-function-function #'helpful-callable)
       (counsel-describe-variable-function #'helpful-variable)
       :config
       (luc/leader-def
         "hh" 'helpful-at-point
         "hm" 'describe-mode
         "hk" 'helpful-key
         "hv" 'counsel-describe-variable
         "hf" 'counsel-describe-function
         "hc" 'helpful-command))
   #+end_src
   
** Debug on Error
   Hopefully helps getting a backtrace to the cause of errors, or just
   getting rid of freezing from =error on process filter=.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/toggle-debug-on-error ()
         "Toggles the local value of `debug-on-error'"
         (interactive)
         (if (eq debug-on-error t)
             (setq-local debug-on-error nil)
           (setq-local debug-on-error t))))
   #+end_src
   
** Y/N Prompts
   Please, ask me "y/n" instead of "yes or no".
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defalias 'yes-or-no-p 'y-or-n-p))
   #+end_src
   
** Finding and reloading configuration
   I visit this file and reload =init.el= quite a lot.  Only makes sense
   to make a couple keybindings for that.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/config-find ()
         "Navigates to my Emacs configuration Org file."
         (interactive)
         (find-file "~/dotfiles/emacs/.ihsec/main/emacs.org"))

       (luc/leader-def
         "ce" 'luc/config-find)

       (defun luc/config-reload ()
         "Reloads init.el"
         (interactive)
         (load-file "~/.emacs.d/init.el"))

       (luc/leader-def
         "cr" 'luc/config-reload))
   #+end_src
   
** Relative Line Numbers
   Display absolute number for current line, relative number for other
   lines.
   #+begin_src emacs-lisp
     (use-package display-line-numbers
       :config
       (setq display-line-numbers-type 'relative)
       (luc/leader-def
         "in" 'display-line-numbers-mode)
       :hook
       (prog-mode . display-line-numbers-mode)
       (conf-mode . display-line-numbers-mode))
   #+end_src
   
** Highlight Current Line
   #+begin_src emacs-lisp
     (use-package hl-line
       :commands hl-line-mode
       :init
       (luc/leader-def
         "il" 'hl-line-mode))
   #+end_src
   
** Highlight Search
   Search matches will remain highlighted until disabled with this
   keybinding.
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (luc/leader-def
         "ih" 'evil-ex-nohighlight))
   #+end_src
   
** Evil Show Registers
   Keybinding for quickly getting Evil register values.
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (luc/leader-def
         "gr" 'evil-show-registers))
   #+end_src
   
** History
   Saving minibuffer histories and additional variables.
   #+begin_src emacs-lisp
     (use-package savehist
       :config
       (setq history-length 250)
       (setq history-delete-duplicates t)
       (setq savehist-additional-variables '(register-alist))
       (savehist-mode 1))
   #+end_src
   
** Backup & Auto-Save
   Backup files essentially keep previous versions of a file,
   different saved stages it has been. =undo-fu-session= seems to be
   taking care of that for me, but still, I thought I'd at least
   configure the backup files so they don't clutter directories and I
   have more control over them.
   
   As for auto-save files, they are created automatically after a
   certain number of inputs to the buffer or seconds passed without
   any changes, so they keep unsaved versions of the visited file so
   they can be recovered in the event of a crash - definitely very
   important.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       ;; Backup
       (setq make-backup-files t
             backup-directory-alist `(("." . "~/.emacs.d/backup-files/"))
             backup-by-copying t
             delete-old-versions t
             version-control t
             kept-old-versions 2
             kept-new-versions 6)
       (defun luc/diff-backup-this-file ()
         "Call `diff-backup' with the current file."
         (interactive)
         (diff-backup (buffer-file-name)))
       ;; Auto-Save
       (setq auto-save-default t
             auto-save-timeout 20
             auto-save-interval 200)
       ;; Keybindings
       (general-def
         :states 'normal
         "gb" 'luc/diff-backup-this-file
         "gr" 'revert-buffer
         "gR" 'recover-this-file)
       (luc/leader-def
         "ar" 'recover-session))
   #+end_src
   
* Windows & Buffers
** Basic keybindings
   Creating comfortable keybindings for common buffer/window related
   commands. Some other relevant keybindings (such as for
   =counsel-switch-buffer=) were set in [[*Ivy, Counsel & Swiper][Ivy, Counsel & Swiper]].
   #+begin_src emacs-lisp
     (luc/leader-def
       "w" 'save-buffer
       "k" 'kill-current-buffer
       "q" 'delete-window
       "ev" 'split-window-horizontally
       "es" 'split-window-vertically
       "en" 'switch-to-next-buffer
       "ep" 'switch-to-prev-buffer
       "eb" 'ibuffer)
   #+end_src

** Switch to Other Buffer
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/switch-to-other-buffer ()
         (interactive)
         (switch-to-buffer (other-buffer)))
       (luc/leader-def
         "<tab>" 'luc/switch-to-other-buffer))
   #+end_src
   
** Winner
   Undo and redo for window actions. I use this a lot when I need to
   have only one window open for a moment, and then want the layout I
   had before back.
   #+begin_src emacs-lisp
     (use-package winner
       :hook (after-init . winner-mode)
       :config
       (luc/leader-def
         "eu" 'winner-undo
         "er" 'winner-redo))
   #+end_src

** Scrolling
   I want my cursor to only move the screen one line at a time when on
   the edges.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq scroll-step 1)
       (setq scroll-conservatively 10000)
       (setq auto-window-vscroll nil))
   #+end_src
   
** Better visual line navigation
   I always thought the visual line motion commands felt a bit clunky
   by default on Evil. Fortunately, =evil-better-visual-line= makes
   those work flawlessly.

   I'm not currently using =evil-better-visual-line-on= by default
   because I don't want to create discrepancies in behavior relating
   to line movement. Those could be very minor though, will probably
   try it out sometime.
   #+begin_src emacs-lisp
     (use-package evil-better-visual-line
       :commands (evil-better-visual-line-next-line
                  evil-better-visual-line-previous-line)
       :config
       (general-def
         :states 'normal
         "gj" 'evil-better-visual-line-next-line
         "gk" 'evil-better-visual-line-previous-line))
   #+end_src
   
** Moving to last line in buffer
   In =evil-mode=, Vim's =G= key is associated with the motion
   =evil-goto-line=, which calls Emacs's =end-of-buffer= when without
   arguments (a line number, in this case). The problem is that
   =end-of-buffer= actually goes beyond what I'd expect, placing the
   cursor after the last newline character, in the beginning of a line
   that isn't really there. I'd prefer it to move to the last actually
   existing line.

   Thankfully, I found someone with an [[https://emacs.stackexchange.com/a/31649][answer]] in Stack Exchange that
   suits me just right. I simply have to add an advice to
   =end-of-buffer=.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/beginning-of-this-or-previous-line (&rest _)
         (beginning-of-line (and (looking-at-p "^$") 0)))
       (advice-add #'end-of-buffer :after #'luc/beginning-of-this-or-previous-line))
   #+end_src
   
** Occur
   Get a buffer with lines from the current buffer that match the
   expression given. That buffer can even become editable, like
   =wdired=!
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (luc/leader-def
         "io" 'occur))
   #+end_src
   
** Avy
   Lots of jumping commands for moving quickly and precisely. In this
   case I'm using Evil's versions of Avy commands so they act as Evil
   motions.
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (luc/leader-def
         "jw" 'evil-avy-goto-word-or-subword-1
         "jW" 'evil-avy-goto-symbol-1
         "ja" 'evil-avy-goto-word-1-above
         "jb" 'evil-avy-goto-word-1-below
         "jk" 'evil-avy-goto-line-above
         "ji" 'evil-avy-goto-char-in-line
         "jl" 'evil-avy-goto-line
         "jj" 'evil-avy-goto-line-below
         "jc" 'evil-avy-goto-char
         "jC" 'evil-avy-goto-char-2))
   #+end_src
   
* Applications & Utilities
** MPDel
   Experimenting with this [[https://www.musicpd.org/][MPD]] client that runs in Emacs. I usually
   use [[https://github.com/ncmpcpp/ncmpcpp][NCMPCPP]], but I'm curious about how Emacs could make the music
   client experience better (there's even an [[https://gitea.petton.fr/mpdel/ivy-mpdel.git][ivy package]] that
   integrates with it, and that's always good news!). I already have
   global keybindings in my window manager for managing toggling the
   playing/paused state, going forwards and backwards in the
   playlist, controlling volume, etc. So this should be used mostly
   just for searching and playlist management.
*** Setup
    I've made some changes to the source code of =libmpdel= and =mpdel= to
    accommodate certain needs of mine, so I'm loading these packages
    from my forks. Briefly, the changes to =mpdel= pertain to changing
    the playlist view, and the changes to =libmpdel= to:
    - Use the =albumartist= tag instead of =artist= - just more useful for me most of the time, and makes it more intuitive for navigating from artist -> album -> song, since the album's contents won't be affected by which artist you selected before.
    - Use =search= and =searchadd= commands instead of =find= and =findadd= - fixes albums appearing empty when opened, which I believe is because =find= commands, when receive an empty string, look for files with tags equal to that content, in this case, empty, while =search= commands treat the empty string as a wildcard.
   
    [[https://github.com/mpdel/mpdel][Base MPDel repository]]

    [[https://github.com/lucasminah/libmpdel][My fork of libmpdel]]

    [[https://github.com/lucasminah/mpdel][My fork of mpdel]]
    #+begin_src emacs-lisp
      (use-package libmpdel
        :straight (libmpdel :type git :host github :repo "mpdel/libmpdel"
                            :fork (:host github :repo "lucasminah/libmpdel"))
        :config
        (use-package mpdel
          :straight (mpdel :type git :host github :repo "mpdel/mpdel"
                           :fork (:host github :repo "lucasminah/mpdel"))
          :commands mpdel-playlist-open
          :hook
          (mpdel-tablist-mode . turn-off-evil-snipe-mode)
          :init
          (evil-collection-mpdel-setup)
          (use-package ivy-mpdel
            :config
            ;; I used the other `ivy-mpdel' functions as a base for this new one.
            (defun luc/ivy-mpdel-albums ()
              "Select music from a list of albums."
              (interactive)
              (ivy-mpdel-list 'albums)))))
    #+end_src
   
*** Keybindings
    #+begin_src emacs-lisp
      (use-package mpdel
        :init
        (general-def
          :keymaps 'mpdel-tablist-mode-map
          :states 'normal
          "l" 'tablist-find-entry
          "h" 'mpdel-song-quit-window
          "=" 'mpdel-core-volume-increase
          "J" 'mpdel-playlist-move-down
          "K" 'mpdel-playlist-move-up
          "c" 'mpdel-song-open
          "m" 'tablist-mark-forward
          "u" 'tablist-unmark-forward
          "t" 'tablist-toggle-marks
          "gu" 'libmpdel-database-update
          "gp" 'mpdel-playlist-open
          "gP" 'mpdel-playlist-open-stored-playlist
          "or" 'mpdel-core-open-artists
          "ol" 'mpdel-core-open-albums
          "sl" 'luc/ivy-mpdel-albums
          "sr" 'ivy-mpdel-list)
        (luc/leader-def
          "mp" 'mpdel-playlist-open))
    #+end_src
    
*** Aesthetics
    #+begin_src emacs-lisp
      (use-package mpdel
        :hook
        (mpdel-tablist-mode . hl-line-mode)
        (mpdel-tablist-mode . display-line-numbers-mode)
        :init
        (set-face-attribute 'mpdel-tablist-song-name-face nil :foreground "#50fa7b")
        (set-face-attribute 'mpdel-tablist-track-face nil :foreground "#8be9fd")
        (set-face-attribute 'mpdel-tablist-album-face nil :foreground "#bd93f9")
        (set-face-attribute 'mpdel-tablist-artist-face nil :foreground "#bd93f9")
        (set-face-attribute 'mpdel-tablist-date-face nil :foreground "#8be9fd")
        (set-face-attribute 'mpdel-playlist-current-song-face nil :weight 'bold))
    #+end_src
    
** Org Mode
   An amazing organization tool. I'm using it to write this very file,
   which really facilitates checking and updating the configuration,
   but there's a lot more to it as well.
   
   [[https://orgmode.org/manual/][Org Manual]]
*** Preferences
    Changing the look and feel of =org-mode=, for maximum organization
    power.
**** Header Font Sizes
     #+begin_src emacs-lisp
       (use-package org
         :config
         (dolist (face '((org-level-1 . 1.1)
                         (org-level-2 . 1.05)
                         (org-level-3 . 1.0)
                         (org-level-4 . 1.0)
                         (org-level-5 . 1.0)
                         (org-level-6 . 1.0)
                         (org-level-7 . 1.0)
                         (org-level-8 . 1.0)))
           (set-face-attribute (car face) nil :height (cdr face))))
     #+end_src
     
**** Variable Pitch Mode 
     Different font pitches for different contexts.
     #+begin_src emacs-lisp
       (use-package org
         :config
         (defun luc/set-my-face-attributes ()
           (set-face-attribute 'fixed-pitch nil :font "UbuntuMono-13")
           (set-face-attribute 'default nil :inherit 'fixed-pitch)
           (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
           (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
           (set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)
           (set-face-attribute 'org-meta-line nil :inherit 'fixed-pitch))
         :hook
         (org-mode . luc/set-my-face-attributes)
         (org-mode . variable-pitch-mode))
     #+end_src
     
**** Ellipsis & Org Bullets
     Header markers are bullets and expansion markers are little
     triangles. A lot cleaner.
     #+begin_src emacs-lisp
       (use-package org
         :config
         (setq org-ellipsis " ▾")
         (use-package
           org-bullets
           :custom
           (org-bullets-bullet-list '("◉" "●" "○" "●" "○" "●" "○"))
           :hook (org-mode . org-bullets-mode)))
         #+end_src
     
**** Visual Line Mode
     For visual line wrapping at words.
     #+begin_src emacs-lisp
       (use-package org
         :hook (org-mode . visual-line-mode))
     #+end_src
     
**** Visual Fill Column
     For centering text in the buffer.
     
     [[https://github.com/joostkremers/visual-fill-column][Git repository]]
     #+begin_src emacs-lisp
       (use-package visual-fill-column
         :init
         (setq visual-fill-column-width 100)
         (setq visual-fill-column-center-text 1)
         :hook
         (org-mode . visual-fill-column-mode))
     #+end_src
     
**** Variables
     #+begin_src emacs-lisp
       (use-package org
         :init
         ;; Headers are folded by default.
         (setq org-startup-folded t)
         ;; Indentation adapts to subtree level.
         (setq org-adapt-indentation t)
         ;; Hide markers for bold, italis, verbatim...
         (setq org-hide-emphasis-markers t))
     #+end_src
     
*** Keybindings
    More Evil keybindings for Org Mode.
    
    [[https://github.com/Somelauw/evil-org-mode][Git repository]]
    #+begin_src emacs-lisp
      (use-package evil-org
        :after org
        :hook ((org-mode . evil-org-mode)
               (evil-org-mode . (lambda () (evil-org-set-key-theme '(navigation
                                                                     insert))))))
    #+end_src

*** Exporting: Ox-Reveal and Htmlize
    Org is pretty easy to export to different formats (by default, =C-c
    C-e= will bring up Org Export Dispatcher with many options). For
    better visualization in HTML (including =reveal.js= presentations),
    these packages really come in handy.
    
    [[https://github.com/hexmode/ox-reveal][Ox Reveal]]
    
    [[https://github.com/hniksic/emacs-htmlize][Htmlize]]
    #+begin_src emacs-lisp
      (use-package ox-reveal
        :init
        (setq org-reveal-mathjax t))

      (use-package htmlize
        :commands htmlize-file)
    #+end_src

*** Org Agenda
    I use this daily to manage my schedule, check deadlines, remember
    dates and keep track of my daily routine. Thankfully =evil-org= can
    bring more Evil keybindings to it as well.
    
    There's a keybinding for toggling =log-mode= in the agenda because
    repeated tasks (from the daily routine, for example) only show up
    there when I mark them as =DONE=, along with the timestamp for when
    I completed them.
    #+begin_src emacs-lisp
      (use-package org
        :hook
        (org-agenda-mode . hl-line-mode)
        :config
        (setq org-directory "~/storage/org/")
        (setq org-agenda-files '("~/storage/org/agenda/"))
        (setq org-agenda-log-mode-items '(closed clock state))
        (use-package evil-org-agenda
          :straight nil
          :config
          (evil-org-agenda-set-keys))
        (general-def
          :states 'motion
          :keymaps 'org-agenda-mode-map
          "w" 'org-save-all-org-buffers
          "l" 'org-agenda-log-mode)
        (luc/leader-def
          "ca" 'org-agenda))
    #+end_src
    
*** Org Capture
    For quickly 'capturing' something in Org files. I mostly use it
    for adding items to the agenda, but have templates for other uses
    as well. Counsel also has its version of it.
    #+begin_src emacs-lisp
      (use-package org
        :config
        (luc/leader-def
          "cc" 'counsel-org-capture)
        (setq org-capture-templates
              '(("d"
                 "Task with deadline"
                 entry (file+headline "agenda/deadlines.org" "Deadlines")
                 "* TODO %^{Task}\nSCHEDULED: %^t DEADLINE: %^t")
                ("t"
                 "Task without deadline"
                 entry (file+headline "agenda/tasks.org" "Tasks")
                 "* TODO %^{Task}\n SCHEDULED: %^t\n%?")
                ;; Saving events and dates as deadlines to get an early
                ;; reminder that they're coming.
                ("e"
                 "Event"
                 entry (file+headline "agenda/events.org" "Events")
                 "* %^{Event}\nDEADLINE: %^T\n")
                ("r"
                 "Dates to remember"
                 entry (file+headline "agenda/dates.org" "Dates")
                 "* %^{Description}\n%DEADLINE: ^t\n")
                ("l"
                 "Link"
                 entry (file+headline "links.org" "Links")
                 "* [[%x][%^{Description}]]\n%U")
                ("i"
                 "Idea/thought"
                 entry (file+headline "thoughts.org" "Ideas & Thoughts")
                 "* %?\n%U"))))
    #+end_src
    
*** Org Babel
    For managing code blocks in Org files.
**** Automatic tangling
     =org-babel-tangle= writes the contents of the source blocks of an
     Org file into a destination file. Since I'm using it to write to
     configuration files, I'd like that function to be called every
     time I save the corresponding Org file.

     Here I make it so =org-babel-tangle= is added to the
     =after-save-hook= on Org files that match my specification. For
     that, I create a variable that holds a list of my Org
     configuration files (so far only this one) and a function to make
     the check.
     #+begin_src emacs-lisp
       (use-package emacs
         :config
         (defvar luc/org-config-dir (expand-file-name "~/dotfiles")
           "Directory containing org files to be tangled to automatically.")
       
         (defun luc/auto-tangle-config-files ()
           "Tangle the current org file, if in `luc/org-config-dir'."
           (when (member (buffer-file-name)
                         (directory-files-recursively luc/org-config-dir "\.org$"))
             (let ((org-confirm-babel-evaluate nil))
               (org-babel-tangle))))
       
         (use-package org
           :hook
           (org-mode . (lambda () (add-hook 'after-save-hook #'luc/auto-tangle-config-files)))))
     #+end_src
     
**** Languages
     Specifying the languages Org Babel should be able to execute and
     get results from in code blocks.
     #+begin_src emacs-lisp
       (use-package org
         :init
         (org-babel-do-load-languages
          'org-babel-load-languages '((python . t)
                                      (shell . t))))
     #+end_src
     
** Imenu
   Jump to points of interest in the buffer.
   #+begin_src emacs-lisp
     (use-package imenu
       :commands (imenu counsel-imenu)
       :init
       (luc/leader-def
         "im" 'counsel-imenu))
   #+end_src
   
** Outline Minor Mode
   Bring =org-mode= like outline capabilities to other major modes!
   #+begin_src emacs-lisp
     (use-package outline
       :init
       ;; `imenu' will match `outline-minor-mode' headings. Still doesn't
       ;; work quite as I'd like it to, but for now it will do.
       (defun luc/imenu-with-outline-hook ()
         (add-to-list 'imenu-generic-expression
                      (list "Headings" (concat "^\\(?:" outline-regexp "\\).*$") 0)))
       :hook
       (prog-mode . outline-minor-mode)
       (outline-minor-mode . luc/imenu-with-outline-hook)
       :config
       (general-def
         :keymaps 'outline-minor-mode-map
         :states 'normal
         "<tab>" 'outline-cycle
         "<backtab>" 'outline-cycle-buffer))
   #+end_src
   
** Dired
   I use =dired= for basically all my file management. Very versatile
   and powerful.
*** Preferences & Keybindings
    #+begin_src emacs-lisp
      (use-package dired
        :straight (:type built-in)
        :custom
        (delete-by-moving-to-trash t)
        (dired-listing-switches "-al --group-directories-first")
        (dired-isearch-filenames 'dwim)        ;; I-search only matches filenames if cursor is on 
                                               ;;   filename column.
        (dired-dwim-target t)                  ;; Deduces where to copy/move files, works great on 
                                               ;;   split windows
        :hook
        (dired-mode . dired-hide-details-mode) ;; Don't show full details by default - toggle with
                                               ;;   open paren
        (dired-mode . hl-line-mode)
        :init
        (general-def
          :keymaps 'dired-mode-map
          :states 'normal
          "h" 'dired-up-directory              ;; \
          "l" 'dired-find-file                 ;; -\ Quick navigation
          "q" 'kill-current-buffer))           ;; For keeping Dired buffers from cluttering.
    #+end_src
   
*** Trashed
    For managing the trash can.

    [[https://github.com/shingo256/trashed][Git repository]]
    #+begin_src emacs-lisp
      (use-package trashed
        :after dired
        :commands trashed
        :init
        (general-def
          :states 'normal
          :keymaps 'dired-mode-map
          "gt" 'trashed))
    #+end_src
    
*** Dired Subtree
    For tree viewing of directories in the style of Org headings. It's
    one of packages from [[https://github.com/Fuco1/dired-hacks][Dired Hacks]].
    #+begin_src emacs-lisp
      (use-package dired-subtree
        :after dired
        :config
        (general-def
          :keymaps 'dired-mode-map
          "<tab>" 'dired-subtree-toggle
          "<backtab>" 'dired-subtree-cycle))
    #+end_src
    
*** Async
    For managing asynchronous operations.

    [[https://github.com/jwiegley/emacs-async][Git repository]]
    #+begin_src emacs-lisp
      (use-package async
        :config
        (use-package dired-async
          :straight nil
          :after dired
          :config
          (dired-async-mode 1)))
    #+end_src
    
*** Dired Open
    For opening different file extensions with external programs. Also
    from [[https://github.com/Fuco1/dired-hacks][Dired Hacks]].
    #+begin_src emacs-lisp
      (use-package dired-open
        :after dired
        :init
        (setq dired-open-extensions '(("mkv" . "mpv")
                                      ("mp4" . "mpv"))))
    #+end_src
    
*** All The Icons Dired
    Pretty symbols!
    
    [[https://github.com/jtbm37/all-the-icons-dired][Git repository]]
    #+begin_src emacs-lisp
      (use-package all-the-icons-dired
        :after dired
        :hook
        (dired-mode . all-the-icons-dired-mode))
    #+end_src
    
*** Writable Dired
    Configuration for =wdired-mode=.
    #+begin_src emacs-lisp
      (use-package wdired
        :straight (:type built-in)
        :after dired
        :init
        (setq wdired-allow-to-change-permissions t)
        (setq wdired-create-parent-directories t))
    #+end_src
    
** Gnus
   Built-in package for managing RSS feeds, news and mail. For now I
   only use it for mail.  I'm using two GMail accounts here, each with
   authentication info in my =.authinfo= file.  In each account it's
   necessary to enable IMAP and either grant access to third party
   apps or create an app password and use that in =.authinfo=. Other
   than that, I have the variables =NAME= and =EMAIL= set in my =.profile=.
   
   I definitely still have things I want to improve on it, so that's
   coming soon. Either that or giving =mu4e= another try.

   [[https://www.emacswiki.org/emacs/GnusTutorial][EmacsWiki Gnus Tutorial]]
   #+begin_src emacs-lisp
     (use-package gnus
       :commands (gnus
                  compose-mail
                  compose-mail-other-window)
       :config
       (setq gnus-expert-user t)
       (setq gnus-select-method '(nnnil ""))
       (setq gnus-secondary-select-methods '((nnimap "uni"
                                                     (nnimap-address "imap.gmail.com")
                                                     (nnimap-server-port 993)
                                                     (nnimap-stream ssl)
                                                     (nnimap-authinfo-file "~/.authinfo"))
                                             (nnimap "personal"
                                                     (nnimap-address "imap.gmail.com")
                                                     (nnimap-server-port 993)
                                                     (nnimap-stream ssl)
                                                     (nnimap-authinfo-file "~/.authinfo"))))
       (setq message-send-mail-function 'smtpmail-send-it
             smtpmail-default-smtp-server "smtp.gmail.com")
       (luc/leader-def
         "ml" 'gnus
         "mc" 'compose-mail
         "mC" 'compose-mail-other-window))
   #+end_src

** Straight
   Some keybindings for accessing =straight.el= commands. The
   interactive =straight-use-package= now serves as my command to try
   out packages.
   #+begin_src emacs-lisp
     (use-package straight
       :init
       (luc/leader-def
         "ss" 'straight-use-package
         "sp" 'straight-pull-package
         "sP" 'straight-pull-all))
   #+end_src
   
** Terminal & Shell
*** Shell & shell commands
    I really like using =shell= if I don't need actual terminal
    emulation, because it really is just an Emacs buffer, with all the
    editing power I could want.
    
    I also want to be able to simply evaluate a command through the
    shell without having to pull up the buffer, so here I make leader
    keybindings for =shell-command= and =async-shell-command=.
    #+begin_src emacs-lisp
      (use-package shell
        :commands shell
        :init
        (luc/leader-def
          "as" 'shell
          "gs" 'shell-command
          "ga" 'async-shell-command))
    #+end_src
    
*** Vterm
    A very good terminal emulator for using inside Emacs. With
    =evil-collection=, it gets a lot more comfortable to use (still not
    as comfortable as the Emacs buffer that =shell= provides, but more
    comfortable nonetheless), and I especially like that it can toggle
    sending =ESC= to Emacs or the shell.
    
    [[https://github.com/akermu/emacs-libvterm][Git repository]]
    #+begin_src emacs-lisp
      (use-package vterm
        :init
        (evil-set-initial-state 'vterm-mode 'insert)
        (luc/leader-def
          "at" 'vterm)
        :commands vterm
        :config
        (evil-collection-vterm-setup)
        (general-def
          :keymaps 'vterm-mode-map
          :states 'insert
          "C-h" 'vterm--self-insert
          "C-l" 'vterm--self-insert
          "C-e" 'evil-scroll-line-down
          "C-y" 'evil-scroll-line-up
          "C-j" 'evil-collection-vterm-toggle-send-escape))
    #+end_src
    
** Hydra
   A package for grouping quick bindings together for a particular
   task. It's a lot easier to understand just seeing an example.
   
   [[https://github.com/abo-abo/hydra][Git repository]]
*** Scaling windows
    Scaling with =[count] C-w [+/-/</>]= doesn't feel very comfortable,
    since I never know exactly how much I want to scale. This hydra
    makes that a lot easier.
    #+begin_src emacs-lisp
      ;; With this, I can press 'SPC es' and then h/j/k/l how many
      ;; times I need to scale the window properly, then 'q' to quit.
      (use-package hydra
        :config
        (defhydra luc/hydra-window-scale ()
          "Scale current window."
          ("h" evil-window-decrease-width "width--")
          ("l" evil-window-increase-width "width++")
          ("j" evil-window-decrease-height "height--")
          ("k" evil-window-increase-height "height++")
          ("q" nil "quit" :exit t))
        (luc/leader-def
          "es" 'luc/hydra-window-scale/body))
    #+end_src
    
** Ispell & Flyspell
   =ispell= is a built-in spellchecking package, and =flyspell-mode= is
   used to highlight misspelled words. I had to install =aspell-en=
   (there are different =aspell= packages for other languages, at least
   in the Arch repositories) for it to work properly, but once that's
   done, it's done!
   #+begin_src emacs-lisp
     (use-package flyspell
       :hook
       (outline-mode . flyspell-mode)
       (text-mode . flyspell-mode)
       :config
       (luc/leader-def
         "is" 'flyspell-buffer
         "iS" 'flyspell-mode
         "id" 'ispell-change-dictionary
         "ic" 'flyspell-auto-correct-word))
   #+end_src
   
** PDF Tools
   My use for this so far have been simply reading PDF files, and it
   works very well.
   
   [[https://github.com/politza/pdf-tools][Git repository]]
   #+begin_src emacs-lisp
     (use-package pdf-tools
       :magic ("%PDF" . pdf-view-mode)
       :hook
       (pdf-view-mode . (lambda () (pdf-view-fit-page-to-window)))
       :config
       (pdf-tools-install
         :no-query t))
   #+end_src
   
** Keycast
   Display key combinations pressed and the command those are bound to
   execute in the modeline. Since I'm using =doom-modeline=, I looked
   for configuration to make it work properly and found this code
   [[https://www.emacswiki.org/emacs/KeyCast][here]].
   
   [[https://github.com/tarsius/keycast][Git repository]]
   #+begin_src emacs-lisp
     (use-package keycast
       :config
       (define-minor-mode luc/keycast-mode
         "Show current command and its key binding in the mode line (working on doom-modeline)."
         :global t
         (if luc/keycast-mode
             (add-hook 'pre-command-hook 'keycast--update t)
           (remove-hook 'pre-command-hook 'keycast--update)))
       (add-to-list 'global-mode-string '("" mode-line-keycast " "))
       (luc/keycast-mode))
   #+end_src
   
** Sudo Edit
   For editing files as the super user.
   #+begin_src emacs-lisp
     (use-package sudo-edit
       :commands sudo-edit
       :init
       (luc/leader-def
         "gS" 'sudo-edit))
   #+end_src
   
* Development
  Building a comfy and powerful development environment.
** LSP & DAP Setup
   Language Server and Debug Adapter protocols. These will be used by
   different languages in different ways, which will be configured in
   [[*Languages][Languages]], so this is only a base setup. Fortunately, neither this
   or the specific setups are hard to get working properly. Here I'm
   also installing [[https://www.flycheck.org/][Flycheck]] so I can use it as my syntax checker (in
   place of =flymake=).
*** LSP Mode
    [[https://emacs-lsp.github.io/lsp-mode/][Overview]]
    #+begin_src emacs-lisp
      (use-package lsp-mode
        :commands (lsp lsp-deferred)
        :init
        (use-package flycheck ;; Syntax checker
          :config
          (luc/leader-def-for-keymaps
            :keymaps 'flycheck-mode-map
            "le" 'flycheck-list-errors
            "lp" 'flycheck-previous-error
            "ln" 'flycheck-next-error))
        (luc/leader-def-for-keymaps
          :keymaps 'lsp-mode-map
          "la" 'lsp-execute-code-action
          "ld" 'lsp-find-declaration
          "lr" 'lsp-rename
          "lf" 'lsp-find-references))
    #+end_src
   
*** LSP UI
    #+begin_src emacs-lisp
      (use-package lsp-ui
        :after lsp-mode
        :hook
        (lsp-mode . lsp-ui-mode)
        :init
        (setq lsp-ui-sideline-show-code-actions t)
        (setq lsp-ui-sideline-show-symbol t)
        (setq lsp-ui-sideline-show-diagnostics t)
        (luc/leader-def-for-keymaps
          :keymaps 'lsp-mode-map
          "ls" 'lsp-ui-sideline-mode))
    #+end_src
    
*** DAP Mode
    [[https://github.com/emacs-lsp/dap-mode][Git repository]]
    #+begin_src emacs-lisp
      (use-package dap-mode
        :hook
        ((lsp-mode . dap-mode)
         (dap-mode . dap-ui-mode)))
    #+end_src
    
** Languages
   Configuring the development environment for different languages
   (mainly with LSP and DAP).
*** Emacs Lisp
    So far, only a package to highlight quoted symbols, makes a lot of
    sense to me. Looking forward to expanding this section.
    
    [[https://github.com/Fanael/highlight-quoted][Highlight Quoted]]
    #+begin_src emacs-lisp
      (use-package highlight-quoted
        :hook
        (emacs-lisp-mode . highlight-quoted-mode)
        (lisp-interaction-mode . highlight-quoted-mode))
    #+end_src
    
*** C/C++
    Using =clangd=, which is looked for by default. For reference:
    [[https://emacs-lsp.github.io/lsp-mode/page/lsp-clangd/]]
    #+begin_src emacs-lisp
      (use-package cpp
        :hook ((c-mode c++-mode) . lsp-deferred))
    #+end_src
    
** Magit & Forge
   =magit= is an amazingly powerful Git front-end. I hadn't known of it
   before, but =forge= allows for working with Git forges (in my case,
   Github) from inside Emacs. Even more awesome!
   
   [[https://magit.vc/][Magit Website]]
   
   [[https://magit.vc/manual/forge/][Forge Manual]]
   #+begin_src emacs-lisp
     (use-package magit
       :commands magit-status
       :init
       (luc/leader-def
         "am" 'magit-status))
       :config
       (use-package forge
         :custom-face
         ;; For correcting error "Invalid face box".
         (forge-topic-label ((t :box (:line-width -1 :style released-button)))))
   #+end_src

