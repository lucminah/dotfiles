#+TITLE: Luc's Emacs Config
#+PROPERTY: header-args :tangle ~/.ihsec/main/init.el
#+REVEAL_THEME: night
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+OPTIONS: toc:nil num:nil

* What is this?
  This is my main GNU Emacs configuration file. =org-babel-tangle= will
  write the Emacs-Lisp code blocks from it to my =early-init.el= (only
  the code block in [[*Early Init][Early Init]]) and =init.el= (the rest of the
  configuration). I'm currently using =ihsec=, a package for switching
  Emacs configurations easily, so my Emacs files are actually in
  =~/.ihsec/main/= (main is just the name I gave this configuration).
  
  After running =org-babel-tangle= and loading the generated
  =early-init.el= and =init.el=, you should have a copy of my Emacs
  configuration. I hope you find this helpful to your own Emacs
  configuration. Happy hacking!
* Base setup
** Early Init
   Other than =init.el=, there's =early-init.el=, which is loaded before
   and allows for a quicker startup. *Note:* I'm making it so this
   section specifically is tangled into =early-init.el= and not =init.el=.
   #+begin_src emacs-lisp :tangle ~/.ihsec/main/early-init.el
     (setq package-enable-at-startup nil)
     (setq inhibit-startup-message t)
     (setq inhibit-splash-screen t)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)
     (tool-bar-mode -1)
     (tooltip-mode -1)
     (set-fringe-mode 5)
   #+end_src
   
** Package Management
   I'm using =straight.el= alongside =use-package= for package management.
   There's a lot of good stuff about these packages, and I definitely
   encourage you to explore their possibilities beyond what you see
   here, but for now: =straight.el= makes package management a lot more
   intuitive and flexible, being able to get specific recipes from
   specific repositories, and managing those as actual
   version-controlled repositories instead of tarballs, like
   =package.el= does. =use-package= provides a very powerful macro for
   loading packages, granting a lot of freedom related to when to
   actually load the package, applying configuration and so
   forth. =straight.el= fortunately integrates with =use-package= out of
   the box.
   
   [[https://github.com/raxod502/straight.el][straight.el]]
  
   [[https://www.emacswiki.org/emacs/UsePackage][EmacsWiki - Use Package]]
   #+begin_src emacs-lisp
     (defvar bootstrap-version)
     (let ((bootstrap-file
            (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
           (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
         (with-current-buffer
             (url-retrieve-synchronously
              "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
              'silent 'inhibit-cookies)
           (goto-char (point-max))
           (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))
     ;; Like `use-package-always-ensure', but for `straight.el'. The flag
     ;; `:straight' can be used to set that explicitly, like `:ensure'.
     (setq straight-use-package-by-default t)
     ;; Clone over SSH.
     (setq straight-vc-git-default-protocol 'ssh)
     ;; Install `use-package'
     (straight-use-package 'use-package)
   #+end_src
  
** Evil & General Setup
   Vim's modal editing, grammar and keybindings are very much pillars
   of my text editing (and now, thanks to Emacs, much
   more). Thankfully, these packages are here to save the day.
*** Evil Mode
    The Extensive Vi Layer itself! Here I load Evil and customizing some
    basic variables. For information on the package I'm using for
    undo-redo actions and setting here as my undo system, see [[*Undo Fu][Undo Fu]].
  
    [[https://evil.readthedocs.io/en/latest/index.html][Documentation]]
    #+begin_src emacs-lisp
      (use-package evil
        :init
        (setq evil-want-keybinding nil    ;; For playing nice with `evil-collection'
              evil-want-Y-yank-to-eol t   ;; Equivalent to 'map Y y$' in Vim
              evil-symbol-word-search t   ;; * and # will search for symbols, not words.
              evil-want-C-u-scroll t      ;; \
              evil-want-C-u-delete t)     ;; -\ I don't use C-u for the universal argument
        :config
        (evil-mode 1)
        (evil-select-search-module 'evil-search-module 'evil-search)
        (evil-set-undo-system 'undo-fu)) ;; See the Undo Fu section.
    #+end_src

*** Evil Collection
    Brings Evil keybindings to many, many different parts of Emacs,
    usually through a setup function. Saves me a lot of rebinding trouble.
   
    [[htTps://github.com/emacs-evil/evil-collection][Git repository]]
    #+begin_src emacs-lisp
      (use-package evil-collection
        :after evil
        :custom
        (evil-collection-setup-minibuffer t)   ;; Modal editing in the minibuffer!
        :init
        (evil-collection-init))
    #+end_src

*** General
    The package I use to manage all my custom keybindings. Going forward
    I'm going to configure a lot of those. I find it complements Evil very
    well, being easy to specify in which states and keymaps the bindings
    apply.

    [[https://github.com/noctuid/general.el][Git repository]]

    Here I created a couple definers that I'll use for many
    keybindings going forward. For the sake of organization, I created
    one for global and one for local keybindings, both using =SPC= as a
    prefix.
    #+begin_src emacs-lisp
      (use-package general
        :config
        ;; For global keybindings.
        (general-create-definer luc/leader-def
          :states '(normal visual motion)
          :keymaps 'override
          :prefix "SPC")
        ;; For local keybindings.
        (general-create-definer luc/leader-def-for-keymaps
          :states '(normal visual motion)
          :prefix "SPC"))
    #+end_src
    
* Editing
** Undo Fu
   My preferred undo system. Works by creating checkpoints on the undo
   actions that keep the functionality linear and sensibly delimited,
   much easier to follow than the default Emacs undo, but also allow
   for unconstrained and non-linear (default) undo/redo, so there's
   still access to all previous states of the file. It also has a
   function to allow it to be limited to a selected region, but I
   haven't tried that out yet.

   [[https://gitlab.com/ideasman42/emacs-undo-fu][Undo Fu]]

   I'm also using =undo-fu-session=, which makes it possible to have a
   persistent change history of files between sessions. The history
   saving is made automatically when writing to the file.
   
   [[https://gitlab.com/ideasman42/emacs-undo-fu-session][Undo Fu Session]]
   #+begin_src emacs-lisp
     (use-package undo-fu
       :custom
       (undo-fu-ignore-keyboard-quit t)    ;; C-g won't disable the checkpoint...
       :config
       (luc/leader-def
         "u" 'undo-fu-disable-checkpoint)  ;; ...but now this will
       (use-package undo-fu-session
         :config
         (global-undo-fu-session-mode)))
   #+end_src

** Evil Surround
   Makes surrounding pairs (including brackets, quotes) a text object
   to be operated on, be it changing, deleting or adding.

   [[https://github.com/emacs-evil/evil-surround][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-surround
       :config
       (global-evil-surround-mode 1))
   #+end_src

** Evil Commentary
   Commenting becomes an Evil verb to be applied on text.

   [[https://github.com/linktohack/evil-commentary][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-commentary
       :config
       (evil-commentary-mode 1))
   #+end_src

** Evil Numbers & Speeddating
   =evil-numbers= brings the functionality of incrementing and
   decrementing the number at point from Vim's normal mode =C-a= and =C-x=
   commands. =speeddating= is very similar, with functions to increment
   and decrement the date at point in various formats.
   
   [[https://github.com/juliapath/evil-numbers][Evil Numbers]]
   
   [[https://github.com/xuchunyang/emacs-speeddating][Speeddating]]
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (use-package speeddating
         :commands (speeddating-increase
                    speeddating-decrease)
         :init
         (general-def
           :states 'normal
           "C-+" 'speeddating-increase
           "C-_" 'speeddating-decrease))
       (use-package evil-numbers
         :commands (evil-numbers/inc-at-pt
                    evil-numbers/dec-at-pt)
         :init
         (setq evil-numbers-pad-default t)
         (general-def
           :states 'normal
           "C-=" 'evil-numbers/inc-at-pt
           "C--" 'evil-numbers/dec-at-pt)))
   #+end_src
   
** Evil Snipe
   Extends Evil's character search capabilities, adding a new motion
   that allows for two character searching. Think of Evil's =f/F/t/T=
   commands, but you give those a two character long string as a
   search term.
   
   By default, the inclusive commands (like =f/F=) are bound to =s/S= in
   the normal state (finally some good use for those chords!) and =z/Z=
   as an operator (say, when it's used as the motion for a =c= command),
   while the exclusive commands (like =t/t=) are bound to nothing in the
   normal state and =x/X= as an operator. For now I've settled on
   binding the exclusive commands to =\= and =|= in the normal state.
   
   On top of that, Snipe has its own versions of =f/F/t/T/;/,= that work
   just like the basic ones but with highlighting for matches and are
   also more customizable (for example, changing the scope of the
   search, which I haven't messed around with yet). Overall a great
   addition to Evil's vocabulary.
   
   [[https://github.com/hlissner/evil-snipe][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-snipe
       :init
       ;; Keep the repeat motions to ; and ,
       (setq evil-snipe-repeat-keys nil)
       (general-def
         :states 'normal
         :keymaps 'evil-snipe-mode-map
         "\\" 'evil-snipe-x
         "|" 'evil-snipe-X)
       :config
       (evil-snipe-mode 1)
       ;; Use Snipe's versions of f/F/t/T/;/,
       (evil-snipe-override-mode 1))
   #+end_src
   
** Electric Pairs
   Matching pairs are 'electric'. Isn't the easiest to explain, but
   once you see it in action, you'll know what it does. Pretty
   intuitive.
   #+begin_src emacs-lisp
     (use-package elec-pair
       :init
       (defun luc/electric-pair-inhibit (char)
         (if (char-equal char ?<) t
           (electric-pair-default-inhibit char)))
       :hook
       (org-mode . (lambda () (setq-local electric-pair-inhibit-predicate
                                          #'luc/electric-pair-inhibit)))
       :config
       (electric-pair-mode 1))
   #+end_src

** Subword
   The concept of "word" gets a bit more flexible, making it so mixed
   lowercase and uppercase characters delimit its
   "subwords". Generally feels more intuitive, definitely improves
   camelCase navigation.
   #+begin_src emacs-lisp
     (use-package subword
       :config
       (global-subword-mode 1))
   #+end_src

** Indentation Preferences
   I've mostly been a tabs user, but recently those started to feel
   less intuitive to me, so I'm setting spaces as the default for now,
   let's see how that goes. Other than that I've made a keybinding for
   indenting the whole buffer, since I find myself pressing =gg=G= a
   lot.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq-default indent-tabs-mode nil)
       (defun luc/evil-indent-whole-buffer ()
         (interactive)
         (evil-with-single-undo
           (save-excursion
             (evil-indent (point-min) (point-max)))))
       (luc/leader-def
         "=" 'luc/evil-indent-whole-buffer))
   #+end_src
   
** Aggressive Indent
   This will actively prevent you from messing indentation up, hence
   aggressive indent. Can feel /too/ aggressive at times, so I only load
   it when I choose to explicitly.
   
   [[https://github.com/Malabarba/aggressive-indent-mode][Git repository]]
   #+begin_src emacs-lisp
     (use-package aggressive-indent
       :commands aggressive-indent-mode
       :init
       (luc/leader-def
         "ia" 'aggressive-indent-mode))
   #+end_src
   
** Hungry Delete
   When deleting whitespace characters, delete all preceding
   whitespace characters.
   
   [[https://github.com/nflath/hungry-delete][Git repository]]
   #+begin_src emacs-lisp
     (use-package hungry-delete
       :init
       (setq hungry-delete-join-reluctantly t)
       (luc/leader-def
         "ih" 'hungry-delete-mode)
       :config
       (global-hungry-delete-mode))
   #+end_src
   
** Transpose
   A really cool Emacs editing feature for switching around or
   'transposing' text objects.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (general-def
         :states 'normal
         "C-t" 'transpose-words
         "C-q" 'transpose-chars
         "C-y" 'transpose-lines))
   #+end_src
   
** Keyboard Macros
   Since Evil macro commands don't play that nicely with Emacs default
   ones (like =edit-last-kbd-macro=, for example, that doesn't affect
   the register where the macro was recorded in), I'm interested in
   creating a setup where I can take advantage of all Emacs has to
   offer concerning keyboard macros, and for that I'm really changing
   the way I think about them coming from Vim - no more saving macros
   to registers and "executing" them back. It actually doesn't feel as
   much of a loss to me, since I can still access the =kmacro-ring= or
   name macros if I need to have access to multiple of them at the
   same time. It's all experimental, I'll see what sorts of problems
   or new ideas come up as I go.
*** Custom functions
    #+begin_src emacs-lisp
      (use-package emacs
        :config
        (defun luc/kmacro-start-or-end-macro (arg)
          "Start defining macro or, if already doing that, end macro."
          (interactive "P")
          (if (or defining-kbd-macro executing-kbd-macro)
              (kmacro-end-macro arg)
            (kmacro-start-macro arg)))
        (defun luc/append-to-last-kbd-macro ()
          "`kmacro-start-macro' prefixed with 'C-u C-u'."
          (interactive)
          (kmacro-start-macro '(16)))
        (defun luc/kmacro-call-macro-single-undo (count)
          "`kmacro-call-macro' as a single evil undo step."
          (interactive "p")
          (evil-with-single-undo
            (kmacro-call-macro count t)))
        (defun luc/consult-kmacro-single-undo (arg)
          "`consult-kmacro' as a single evil undo step."
          (interactive "p")
          (evil-with-single-undo
            (consult-kmacro arg))))
    #+end_src
   
*** Keybindings
    #+begin_src emacs-lisp
      (use-package emacs
        :config
        (general-unbind
          :states 'normal
          "q"
          "@")
        (general-def
          :states 'normal
          "q" 'luc/kmacro-start-or-end-macro
          "Q" 'luc/append-to-last-kbd-macro
          "@@" 'luc/kmacro-call-macro-single-undo
          "@e" 'edit-last-kbd-macro
          "@k" 'luc/consult-kmacro-single-undo
          "@a" 'kmacro-add-counter)
        (luc/leader-def
          "gn" 'name-last-kbd-macro
          "gq" 'insert-kbd-macro)
        (general-def
          :states 'insert
          "C-q" 'kmacro-insert-counter))
    #+end_src
    
* Minibuffer & Completion
** Basic minibuffer commands
   Emacs minibuffer commands I use all the time, including an
   alternative keybinding for =execute-extended-command=.
   #+begin_src emacs-lisp
     (use-package emacs
       :init
       (general-def
         :keymaps 'override
         :states '(normal visual motion)
         "C-SPC" 'execute-extended-command)
       (general-def
         :keymaps 'minibuffer-local-map
         :states 'normal
         "<escape>" 'minibuffer-keyboard-quit)
       (luc/leader-def
         "SPC" 'execute-extended-command
         "f" 'find-file
         "d" 'dired))
   #+end_src
   
** Consult
   A collection of commands based on the =completing-read= function that
   substitute built-in functions such as =imenu= and brings new
   functionality and integration through commands like =consult-find=.

   [[https://github.com/minad/consult][Git repository]]
   #+begin_src emacs-lisp
     (use-package consult
       :hook
       ;; Use `consult-completion-in-region' if Vertico is enabled.
       (vertico-mode . (lambda ()
                         (setq completion-in-region-function
                               (if vertico-mode
                                   #'consult-completion-in-region
                                 #'completion--in-region))))
       :init
       ;; I'd like minibuffer completion with TAB.
       (setq tab-always-indent 'complete)
       ;; I use `fd' instead of `find'.
       (setq consult-find-command "fd --color=never --hidden ARG OPTS")
       (luc/leader-def
         "b" 'consult-buffer
         "l" 'consult-line
         "af" 'consult-find
         "ag" 'consult-ripgrep
         "gi" 'consult-imenu
         "go" 'consult-outline
         "gf" 'consult-focus-lines)
       :config
       ;; Loading previews only when explicitly choosing to with a
       ;; keybinding. Significantly improves speed of these commands,
       ;; specially ones that use external programs such as `grep'.
       (consult-customize
        consult-ripgrep consult-git-grep consult-grep
        consult-bookmark consult-recent-file consult-xref
        consult--source-file consult--source-project-file consult--source-bookmark
        :preview-key (kbd "C-o")))
   #+end_src
   
** Vertico
   A completion UI that aims to have full compatibility with built-in
   Emacs completion commands. This stability really shines through,
   making it pretty easy to configure and maintain and integrate with
   other packages.

   [[https://github.com/minad/vertico][Git repository]]
   #+begin_src emacs-lisp
     (use-package vertico
       :init
       (setq enable-recursive-minibuffers t)
       (setq vertico-cycle t)
       (general-def
         :keymaps 'vertico-map
         :states 'insert
         "C-k" 'vertico-previous
         "C-j" 'vertico-next
         "C-l" 'vertico-exit)
       (general-def
         :keymaps 'vertico-map
         :states 'normal
         "k" 'vertico-previous
         "j" 'vertico-next
         "l" 'vertico-exit)
       (vertico-mode 1))
   #+end_src
   
** Marginalia
   Adds useful annotations to minibuffer selection candidates, such as
   the first line of function docstrings, value of a variable or
   permission details of a file, for example.
   
   [[https://github.com/minad/marginalia][Git repository]]
   #+begin_src emacs-lisp
     (use-package marginalia
       :init
       (marginalia-mode 1))
   #+end_src
   
** Orderless
   A completion style that allows for very flexible matching,
   specially out of order (components "file" and "find" in this order
   would still match =find-file=, for example). It's also customizable
   through the use of different matching styles (regular expressions,
   literals, prefixes...) and dispatchers, functions that can change
   the matching style and its behavior on the fly. Here I define some
   of these dispatchers that check the suffix of the symbol to
   determine it should be read as a literal, for example.

   I'm setting the =basic= completion style as the primary one because
   loading a massive =orderless= list of matches in something like
   =company-mode= can really add latency sometimes, which is not
   comfortable. Through the use of the dispatchers and separators,
   it's possible to explicitly jump into the =orderless= style when I
   want, so it's not a big deal, but I'd still like to evolve my setup
   to a point where I can get rid of the =basic= style. I'm also setting
   a category override so that I can have filename expansion when in
   that context through the =partial-completion= style.

   [[https://github.com/oantolin/orderless][Git repository]]
   #+begin_src emacs-lisp
     (use-package orderless
       :init
       (defun luc/orderless-strict-leading-initialism-dispatcher (pattern _index _total)
         (when (string-suffix-p "|" pattern)
           `(orderless-strict-leading-initialism . ,(substring pattern 0 -1))))
     
       (defun luc/orderless-literal-dispatcher (pattern _index _total)
         (when (string-suffix-p "=" pattern)
           `(orderless-literal . ,(substring pattern 0 -1))))
     
       (defun luc/orderless-start-with-regexp-dispatcher (pattern _index _total)
         (when (string-suffix-p "+" pattern)
           `(orderless-regexp . ,(substring (concat "^" pattern) 0 -1))))
     
       (setq completion-styles '(basic orderless)
             completion-category-defaults nil
             completion-category-overrides '((file (styles . (partial-completion)))))
       (setq orderless-component-separator "[ #]"
             orderless-matching-styles '(orderless-literal orderless-prefixes orderless-regexp)
             orderless-style-dispatchers '(luc/orderless-start-with-regexp-dispatcher
                                           luc/orderless-strict-leading-initialism-dispatcher
                                           luc/orderless-literal-dispatcher)))
   #+end_src
   
** Embark
   Adds the concept of "acting" on something, primarily minibuffer
   selection candidates, but things like the symbol at point are also
   valid targets. In different contexts, acting will have different
   actions available. For example, calling =embark-act= on a candidate
   of =describe-variable= will include actions to find references to,
   set and customize that variable, among others.

   Among its most interesting actions, in my opinion, is "export",
   which creates a buffer in the appropriate major mode with the
   current minibuffer candidates that can be acted upon, kept for
   reference, used as an index (if exporting candidates from a line
   filtering command, for example).

   Here I set global keybindings for important Embark commands,
   primarily =embark-act=, of course, but also =embark-dwim= which runs
   the default action on the target and =embark-export=, since I use it
   so much. Embark is a really interesting package I'm excited to keep
   on expanding for my needs.

   [[https://github.com/oantolin/embark][Git repository]]
   #+begin_src emacs-lisp
     (use-package embark
       :init
       (general-def
         :keymaps 'override
         :states '(insert normal visual emacs motion)
         "C-;" 'embark-act
         "C-," 'embark-dwim
         "C-." 'embark-export)
       (use-package embark-consult
         :after (embark consult)
         :demand t
         :hook
         (embark-collect-mode . consult-preview-at-point-mode)))
   #+end_src
   
** Minibuffer History
   Saving minibuffer histories and additional variables, along some
   keybindings for easy navigation.
   #+begin_src emacs-lisp
     (use-package savehist
       :init
       (general-def
         :keymaps 'minibuffer-local-map
         :states 'insert
         "C-p" 'previous-history-element
         "C-n" 'next-history-element)
       :config
       (setq history-length 250)
       (setq history-delete-duplicates t)
       (setq savehist-additional-variables '(register-alist))
       (savehist-mode 1))
   #+end_src
   
** Fasd
   [[https://github.com/clvv/fasd][fasd]] is a command line utility that keeps track of visited files
   and directories and ranks them based on how frequently and how
   recently you've been there. When I learned about it I really liked
   the idea, but most of my file browsing is done in Emacs, of course,
   so it alone wouldn't cut it. Fortunately there is an Emacs package
   for it!

   I didn't like everything about the package by default though, since
   it would always prompt me to select from a list, which isn't as
   slick as just typing a small query and jumping straight to what I
   want, so I made a fork of it. The main different is just that, it
   will prompt for a query and take the first result =fasd= provides. If
   a list is desired, simply pass the new argument =LIST= as =t=.

   [[https://github.com/emacsmirror/fasd][Base emacs-fasd Git repository]]

   [[https://github.com/lucasminah/fasd][My fork]]
   #+begin_src emacs-lisp
     (use-package fasd
       :straight (fasd :type git :host github :repo "emacsmirror/fasd"
                       :fork (:type git :repo "lucasminah/fasd"))
       :init
       (defun luc/fasd-find-select ()
         "`fasd-find-file' promps for selection from list of results."
         (interactive)
         (fasd-find-file nil nil t))
       (luc/leader-def
         "z" 'fasd-find-file
         "Z" 'luc/fasd-find-select)
       (global-fasd-mode 1))
   #+end_src
   
** Company
   A great auto-completion package. Alongside it I'm using
   =company-box=, a nice front-end with pretty symbols, pop-up
   documentation and a stable font for the candidates that doesn't
   change with =variable-pitch-mode= (that really doesn't look good).
   
   I do some remapping to make it more comfortable to use, especially
   so it doesn't interfere with Evil's completion commands (=C-n= and
   =C-p=) or any =TAB= commands (jumping, activating snippets,
   indentation...).
   
   [[https://company-mode.github.io/][Company documentation]]
   
   [[https://github.com/sebastiencs/company-box][Company Box]]
*** Setup
    #+begin_src emacs-lisp
      (use-package company
        :after orderless
        :hook
        (prog-mode . company-mode)
        (outline-mode . company-mode)
        (text-mode . company-mode)
        (shell-mode . company-mode)
        :init
        ;; Highlight orderless matches with one face (can't have multiple
        ;; ones so far)
        (defun luc/company-orderless-match-one-face (fn &rest args)
          (let ((orderless-match-faces [completions-common-part]))
            (apply fn args)))
        (advice-add 'company-capf--candidates :around #'luc/company-orderless-match-one-face)
        (setq company-idle-delay 0
              company-minimum-prefix-length 1
              company-tooltip-idle-delay 0
              company-selection-wrap-around t
              company-abort-on-unique-match nil)
        (use-package company-box
          :hook
          (company-mode . company-box-mode)
          :init
          (setq company-box-doc-delay 0.2)))
    #+end_src
    
*** Keybindings
    #+begin_src emacs-lisp
      (use-package company
        :config
        (general-unbind
          :keymaps 'company-active-map
          "<return>"
          "<tab>"
          "TAB")
        (general-def
          :keymaps 'company-active-map
          "C-h" 'company-abort
          "C-l" 'company-complete-selection
          "C-j" 'company-select-next
          "C-k" 'company-select-previous
          "C-n" 'evil-complete-next
          "C-p" 'evil-complete-previous)
        (luc/leader-def
          "ic" 'company-mode))
    #+end_src
    
** YASnippet
   For expandable snippets - for and while loops, main function
   definition, if statements... Anything you'd like to have easily
   printed out and jump to specific parts of it, customized for the
   current major mode. Pretty easy to change the existing snippets or
   create your own. The package =yasnippet-snippets= contains a bunch
   ready to use.
   
   I'm using it in conjunction with =company= - right now the
   keybindings feel right in both keymaps, but I should test it more
   to make sure. Also gave a keybinding to the =company-yasnippet=
   function, which gives =company= completion for =yasnippet= snippet
   candidates, but that requires further testing and experimentation,
   since so far I've only got it to work when =company= is not active.
   
   [[https://github.com/joaotavora/yasnippet][YASnippet]]
   
   [[https://github.com/AndreaCrotti/yasnippet-snippets][YASnippet Snippets]]
   #+begin_src emacs-lisp
     (use-package yasnippet
       :hook 
       (company-mode . yas-minor-mode)
       :config
       (general-def
         :keymaps 'yas-keymap
         "<tab>" 'yas-next-field-or-maybe-expand
         "<backtab>" 'yas-prev-field)
       (general-def
         :keymaps 'company-mode-map
         :states 'insert
         "C-l" 'company-yasnippet)
       (use-package yasnippet-snippets))
   #+end_src
   
* Interface & Interactions
** Theme, Modeline & Default Font
   Trying out some Doom themes and the Doom modeline. Looking pretty
   good.
  
   [[https://github.com/hlissner/emacs-doom-themes][Doom themes]]

   [[https://github.com/seagle0128/doom-modeline][Doom modeline]]
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (use-package doom-themes
         :config
         (load-theme 'doom-dracula t))
       (use-package doom-modeline
         :custom
         (doom-modeline-window-width-limit 154)
         (doom-modeline-icon t)
         (doom-modeline-height 30)
         :init
         (doom-modeline-mode 1))
       ;; Making this the default font for this and future frames
       (add-to-list 'default-frame-alist '(font . "UbuntuMono-13")))
   #+end_src

** Hide Mode Line
   Sometimes I just need to clean the screen that bit more by hiding
   the modeline. Thankfully, this package provides a minor mode for
   that, so I can toggle it pretty easily.
   
   [[https://github.com/hlissner/emacs-hide-mode-line][Git repository]]
   #+begin_src emacs-lisp
     (use-package hide-mode-line
       :commands hide-mode-line-mode
       :init
       (luc/leader-def
         "ib" 'hide-mode-line-mode))
   #+end_src
   
** TTY Faces
   Here I change some face attributes for when using =emacs[client] [-nw|-t|--tty]=.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/tty-set-face-attributes (&optional frame)
         "If the created frame is in a tty, set these face attributes."
         (unless (display-graphic-p frame)
           (set-face-attribute 'hl-line frame :reverse-video t)
           ;; Use terminal's background.
           (set-face-background 'default "unspecified-bg" frame)))
       (add-to-list 'after-make-frame-functions 'luc/tty-set-face-attributes))
   #+end_src
   
** Dashboard
   A nice starting buffer for Emacs.
   
   [[https://github.com/emacs-dashboard/emacs-dashboard][Git repository]]
   #+begin_src emacs-lisp
     (use-package dashboard
       :config
       (dashboard-setup-startup-hook)
       (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
       :custom
       (dashboard-center-content t)
       (dashboard-banner-logo-title "Welcome to Luc's Emacs!")
       (dashboard-set-heading-icons t)
       (dashboard-set-file-icons t)
       (dashboard-set-navigator t)
       (dashboard-set-footer nil)
       (dashboard-items '((bookmarks . 10)
                          (recents  . 20)))
       (dashboard-navigator-buttons
        `(((,(all-the-icons-octicon "mark-github" :height 1.1 :v-adjust 0.0)
            "Homepage"
            "Browse homepage"
            (lambda (&rest _) (browse-url "https://github.com/")))))))
   #+end_src
   
** Bookmarks
   A keybinding for accessing =consult-bookmark=. It can be used for
   setting and jumping to bookmarks so, pretty useful.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq bookmark-file "~/.ihsec/main/bookmarks")
       (luc/leader-def
         "ab" 'consult-bookmark))
   #+end_src
   
** Rainbow Delimiters
   Bracket pairs have matching colors.
   
   [[https://github.com/Fanael/rainbow-delimiters][Git repository]]
   #+begin_src emacs-lisp
     (use-package rainbow-delimiters
       :hook
       (prog-mode . rainbow-delimiters-mode))
   #+end_src

** Rainbow Mode
   Hex codes in text have their background colored.
   
   [[https://github.com/emacsmirror/rainbow-mode][Git repository]]
   #+begin_src emacs-lisp
     (use-package rainbow-mode
       :hook (prog-mode
              conf-mode
              fundamental-mode
              org-mode)
       :init
       (luc/leader-def
         "ir" 'rainbow-mode))
   #+end_src

** Help
   Emacs is great at discoverability. Here I set keybindings for help
   ("describe") commands, and load the =helpful= package for better help
   buffers.
   
   [[https://github.com/Wilfred/helpful][Git repository]]
   #+begin_src emacs-lisp
     (use-package helpful
       :config
       (luc/leader-def
         "hh" 'helpful-at-point
         "hm" 'describe-mode
         "hk" 'helpful-key
         "hv" 'helpful-variable
         "hf" 'helpful-function
         "hF" 'helpful-callable
         "hc" 'helpful-command))
   #+end_src
   
** Debug on Error
   Hopefully helps getting a backtrace to the cause of errors, or just
   getting rid of freezing from =error on process filter=.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/toggle-debug-on-error ()
         "Toggles the local value of `debug-on-error'"
         (interactive)
         (if (eq debug-on-error t)
             (setq-local debug-on-error nil)
           (setq-local debug-on-error t))))
   #+end_src
   
** Y/N Prompts
   Please, ask me "y/n" instead of "yes or no".
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defalias 'yes-or-no-p 'y-or-n-p))
   #+end_src
   
** Finding and reloading configuration
   I visit this file and reload =init.el= quite a lot.  Only makes sense
   to make a couple keybindings for that.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/config-find ()
         "Navigates to my Emacs configuration Org file."
         (interactive)
         (find-file "~/dotfiles/emacs/.ihsec/main/emacs.org"))

       (luc/leader-def
         "ce" 'luc/config-find)

       (defun luc/config-reload ()
         "Reloads init.el"
         (interactive)
         (load-file "~/.emacs.d/init.el"))

       (luc/leader-def
         "cr" 'luc/config-reload))
   #+end_src
   
** Relative Line Numbers
   Display absolute number for current line, relative number for other
   lines.
   #+begin_src emacs-lisp
     (use-package display-line-numbers
       :config
       (setq display-line-numbers-type 'relative)
       (luc/leader-def
         "in" 'display-line-numbers-mode)
       :hook
       (prog-mode . display-line-numbers-mode)
       (conf-mode . display-line-numbers-mode))
   #+end_src
   
** Highlight Current Line
   #+begin_src emacs-lisp
     (use-package hl-line
       :commands hl-line-mode
       :init
       (luc/leader-def
         "il" 'hl-line-mode))
   #+end_src
   
** Highlight Search
   Search matches will remain highlighted until disabled with this
   keybinding.
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (luc/leader-def
         "ih" 'evil-ex-nohighlight))
   #+end_src
   
** Evil Show Registers
   Keybinding for quickly getting Evil register values.
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (luc/leader-def
         "gr" 'evil-show-registers))
   #+end_src
   
** Backup & Auto-Save
   Backup files essentially keep previous versions of a file,
   different saved stages it has been. =undo-fu-session= seems to be
   taking care of that for me, but still, I thought I'd at least
   configure the backup files so they don't clutter directories and I
   have more control over them.
   
   As for auto-save files, they are created automatically after a
   certain number of inputs to the buffer or seconds passed without
   any changes, so they keep unsaved versions of the visited file so
   they can be recovered in the event of a crash - definitely very
   important.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       ;; Backup
       (setq make-backup-files t
             backup-directory-alist `(("." . "~/.emacs.d/backup-files/"))
             backup-by-copying t
             delete-old-versions t
             version-control t
             kept-old-versions 2
             kept-new-versions 6)
       (defun luc/diff-backup-this-file ()
         "Call `diff-backup' with the current file."
         (interactive)
         (diff-backup (buffer-file-name)))
       ;; Auto-Save
       (setq auto-save-default t
             auto-save-timeout 20
             auto-save-interval 200)
       ;; Keybindings
       (general-def
         :states 'normal
         "gb" 'luc/diff-backup-this-file
         "gr" 'revert-buffer
         "gR" 'recover-this-file)
       (luc/leader-def
         "ar" 'recover-session))
   #+end_src
   
** Fcitx
   [[https://fcitx-im.org/wiki/Fcitx_5][Fcitx]] is the input method framework I use for managing different
   keyboard layouts and language specific input. This package provides
   automatic disabling of the Fcitx input method (and possibly
   others - check final section in the repo's README) in certain
   contexts where it doesn't make sense to use them. For me, when I
   use it to type in Japanese, it's not really useful to have Fcitx
   enabled in the normal state, for example - just makes all
   keybindings unusable, since none of them use Japanese
   characters. All of its functionalities are well explained in the
   repo.

   [[https://github.com/cute-jumper/fcitx.el][Git repository]]
   #+begin_src emacs-lisp
     (use-package fcitx
       :init
       (fcitx-aggressive-setup)
       (setq fcitx-use-dbus t))
   #+end_src
   
* Windows & Buffers
** Basic keybindings
   Creating comfortable keybindings for common buffer/window related
   commands. Some other relevant keybindings (such as for
   =consult-buffer=) were set in "Minibuffer & Completion".
   #+begin_src emacs-lisp
     (luc/leader-def
       "w" 'save-buffer
       "k" 'kill-current-buffer
       "q" 'delete-window
       "ev" 'split-window-horizontally
       "es" 'split-window-vertically
       "en" 'switch-to-next-buffer
       "ep" 'switch-to-prev-buffer
       "eb" 'ibuffer)
   #+end_src

** Switch to Other Buffer
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/switch-to-other-buffer ()
         (interactive)
         (switch-to-buffer (other-buffer)))
       (luc/leader-def
         "<tab>" 'luc/switch-to-other-buffer))
   #+end_src
   
** Winner
   Undo and redo for window actions. I use this a lot when I need to
   have only one window open for a moment, and then want the layout I
   had before back.
   #+begin_src emacs-lisp
     (use-package winner
       :hook (after-init . winner-mode)
       :config
       (luc/leader-def
         "eu" 'winner-undo
         "er" 'winner-redo))
   #+end_src

** Scrolling
   I want my cursor to only move the screen one line at a time when on
   the edges.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq scroll-step 1)
       (setq scroll-conservatively 10000)
       (setq auto-window-vscroll nil))
   #+end_src
   
** Better visual line navigation
   I always thought the visual line motion commands felt a bit clunky
   by default on Evil. Fortunately, =evil-better-visual-line= makes
   those work flawlessly.

   I'm not currently using =evil-better-visual-line-on= by default
   because I don't want to create discrepancies in behavior relating
   to line movement. Those could be very minor though, will probably
   try it out sometime.
   #+begin_src emacs-lisp
     (use-package evil-better-visual-line
       :commands (evil-better-visual-line-next-line
                  evil-better-visual-line-previous-line)
       :config
       (general-def
         :states 'normal
         "gj" 'evil-better-visual-line-next-line
         "gk" 'evil-better-visual-line-previous-line))
   #+end_src
   
** Beginning and end of line
   Some Vim bindings that always mildly annoyed me were =0/$= and
   =^/g_=. Moving to the beginning and end of line or first and last
   non-blank character in the line are very useful motions, yet their
   bindings are not that comfortable to hit.
   
   =C-h= and =C-l= are, by default, Emacs commands for describing (already
   taken care of by my leader keybindings starting with =SPC h=) and
   cycling the position of the pointer in the screen (already taken
   care of by Evil's =zz=, =zt= and =zb=), so they seem like prime
   candidates to these useful navigation commands, alongside their
   capital counterparts.
   #+begin_src emacs-lisp
     (use-package evil
       :config
       (general-def
         :states 'normal
         "C-h" 'evil-beginning-of-line
         "C-S-h" 'evil-first-non-blank
         "C-l" 'evil-end-of-line
         "C-S-l" 'evil-last-non-blank))
   #+end_src
   
** Moving to last line in buffer
   In =evil-mode=, Vim's =G= key is associated with the motion
   =evil-goto-line=, which calls Emacs's =end-of-buffer= when without
   arguments (a line number, in this case). The problem is that
   =end-of-buffer= actually goes beyond what I'd expect, placing the
   cursor after the last newline character, in the beginning of a line
   that isn't really there. I'd prefer it to move to the last actually
   existing line.

   Thankfully, I found someone with an [[https://emacs.stackexchange.com/a/31649][answer]] in Stack Exchange that
   suits me just right. I simply have to add an advice to
   =end-of-buffer=.
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (defun luc/beginning-of-this-or-previous-line (&rest _)
         (beginning-of-line (and (looking-at-p "^$") 0)))
       (advice-add #'end-of-buffer :after #'luc/beginning-of-this-or-previous-line))
   #+end_src
   
** Occur
   Get a buffer with lines from the current buffer that match the
   expression given. That buffer can even become editable, like
   =wdired=!
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (luc/leader-def
         "gu" 'occur))
   #+end_src
   
** Avy
   Lots of jumping commands for moving quickly and precisely. In this
   case I'm using Evil's versions of Avy commands so they act as Evil
   motions.

   Evil's =z= bindings do a lot related to outline closing and opening,
   but I feel =outline-cycle= bound to =TAB= is all I need, so I'm willing
   to use some of these keybindings for =avy= motions - they're very
   powerful so I want them pretty easy to hit.
   #+begin_src emacs-lisp
     (use-package evil
       :init
       (general-def
         :states 'normal
         :keymaps 'override
         "zw" 'evil-avy-goto-word-or-subword-1
         "zs" 'evil-avy-goto-symbol-1
         "zk" 'evil-avy-goto-line-above
         "zl" 'evil-avy-goto-line
         "zj" 'evil-avy-goto-line-below
         "zc" 'evil-avy-goto-char-2
         "zx" 'evil-avy-goto-char))
   #+end_src
   
* Applications & Utilities
** MPDel
   Experimenting with this [[https://www.musicpd.org/][MPD]] client that runs in Emacs. I usually
   use [[https://github.com/ncmpcpp/ncmpcpp][NCMPCPP]], but I'm curious about how Emacs could make the music
   client experience better. I already have global keybindings in my
   window manager for managing toggling the playing/paused state,
   going forwards and backwards in the playlist, controlling volume,
   etc. So this should be used mostly just for searching and playlist
   management.
*** Setup
    I've made some changes to the source code of =libmpdel= and =mpdel= to
    accommodate certain needs of mine, so I'm loading these packages
    from my forks. Briefly, the changes to =mpdel= pertain to changing
    the playlist view, and the changes to =libmpdel= to:
    - Use the =albumartist= tag instead of =artist= - just more useful for me most of the time, and makes it more intuitive for navigating from artist -> album -> song, since the album's contents won't be affected by which artist you selected before.
    - Use =search= and =searchadd= commands instead of =find= and =findadd= - fixes albums appearing empty when opened, which I believe is because =find= commands, when receive an empty string, look for files with tags equal to that content, in this case, empty, while =search= commands treat the empty string as a wildcard.
   
    [[https://github.com/mpdel/mpdel][Base MPDel repository]]

    [[https://github.com/lucasminah/libmpdel][My fork of libmpdel]]

    [[https://github.com/lucasminah/mpdel][My fork of mpdel]]
    #+begin_src emacs-lisp
      (use-package libmpdel
        :straight (libmpdel :type git :host github :repo "mpdel/libmpdel"
                            :fork (:host github :repo "lucasminah/libmpdel"))
        :config
        (use-package mpdel
          :straight (mpdel :type git :host github :repo "mpdel/mpdel"
                           :fork (:host github :repo "lucasminah/mpdel"))
          :commands mpdel-playlist-open
          :hook
          (mpdel-tablist-mode . turn-off-evil-snipe-mode)
          :init
          (evil-collection-mpdel-setup)))
    #+end_src
   
*** Keybindings
    #+begin_src emacs-lisp
      (use-package mpdel
        :init
        (general-def
          :keymaps 'mpdel-tablist-mode-map
          :states 'normal
          "l" 'tablist-find-entry
          "h" 'mpdel-song-quit-window
          "=" 'mpdel-core-volume-increase
          "J" 'mpdel-playlist-move-down
          "K" 'mpdel-playlist-move-up
          "c" 'mpdel-song-open
          "m" 'tablist-mark-forward
          "u" 'tablist-unmark-forward
          "t" 'tablist-toggle-marks
          "gu" 'libmpdel-database-update
          "gp" 'mpdel-playlist-open
          "gP" 'mpdel-playlist-open-stored-playlist
          "or" 'mpdel-core-open-artists
          "ol" 'mpdel-core-open-albums)
        (luc/leader-def
          "mp" 'mpdel-playlist-open))
    #+end_src
    
*** Aesthetics
    #+begin_src emacs-lisp
      (use-package mpdel
        :hook
        (mpdel-tablist-mode . hl-line-mode)
        (mpdel-tablist-mode . display-line-numbers-mode)
        :init
        (set-face-attribute 'mpdel-tablist-song-name-face nil :foreground "#50fa7b")
        (set-face-attribute 'mpdel-tablist-track-face nil :foreground "#8be9fd")
        (set-face-attribute 'mpdel-tablist-album-face nil :foreground "#bd93f9")
        (set-face-attribute 'mpdel-tablist-artist-face nil :foreground "#bd93f9")
        (set-face-attribute 'mpdel-tablist-date-face nil :foreground "#8be9fd")
        (set-face-attribute 'mpdel-playlist-current-song-face nil :weight 'bold))
    #+end_src
    
** Imenu
   Jump to points of interest in the buffer.
   #+begin_src emacs-lisp
     (use-package imenu
       :commands (imenu consult-imenu)
       :init
       (luc/leader-def
         "im" 'consult-imenu))
   #+end_src
   
** Outline Minor Mode
   Bring =org-mode= like outline capabilities to other major modes!
   #+begin_src emacs-lisp
     (use-package outline
       :hook
       (prog-mode . outline-minor-mode)
       :config
       (general-def
         :keymaps 'outline-minor-mode-map
         :states 'normal
         "<tab>" 'outline-cycle
         "<backtab>" 'outline-cycle-buffer))
   #+end_src
   
** Dired
   I use =dired= for basically all my file management. Very versatile
   and powerful.
*** Preferences & Keybindings
    #+begin_src emacs-lisp
      (use-package dired
        :straight (:type built-in)
        :custom
        (delete-by-moving-to-trash t)
        (dired-listing-switches "-al --group-directories-first")
        (dired-isearch-filenames 'dwim)        ;; I-search only matches filenames if cursor is on 
                                               ;;   filename column.
        (dired-dwim-target t)                  ;; Deduces where to copy/move files, works great on 
                                               ;;   split windows
        :hook
        (dired-mode . dired-hide-details-mode) ;; Don't show full details by default - toggle with
                                               ;;   open paren
        (dired-mode . hl-line-mode)
        :init
        (general-def
          :keymaps 'dired-mode-map
          :states 'normal
          "h" 'dired-up-directory              ;; \
          "l" 'dired-find-file                 ;; -\ Quick navigation
          "q" 'kill-current-buffer))           ;; For keeping Dired buffers from cluttering.
    #+end_src
   
*** Trashed
    For managing the trash can.

    [[https://github.com/shingo256/trashed][Git repository]]
    #+begin_src emacs-lisp
      (use-package trashed
        :after dired
        :commands trashed
        :init
        (general-def
          :states 'normal
          :keymaps 'dired-mode-map
          "gt" 'trashed))
    #+end_src
    
*** Dired Subtree
    For tree viewing of directories in the style of Org headings. It's
    one of packages from [[https://github.com/Fuco1/dired-hacks][Dired Hacks]].
    #+begin_src emacs-lisp
      (use-package dired-subtree
        :after dired
        :config
        (general-def
          :keymaps 'dired-mode-map
          "<tab>" 'dired-subtree-toggle
          "<backtab>" 'dired-subtree-cycle))
    #+end_src
    
*** Async
    For managing asynchronous operations.

    [[https://github.com/jwiegley/emacs-async][Git repository]]
    #+begin_src emacs-lisp
      (use-package async
        :config
        (use-package dired-async
          :straight nil
          :after dired
          :config
          (dired-async-mode 1)))
    #+end_src
    
*** Dired Open
    For opening different file extensions with external programs. Also
    from [[https://github.com/Fuco1/dired-hacks][Dired Hacks]].
    #+begin_src emacs-lisp
      (use-package dired-open
        :after dired
        :init
        (setq dired-open-extensions '(("mkv" . "mpv")
                                      ("mp4" . "mpv"))))
    #+end_src
    
*** All The Icons Dired
    Pretty symbols!
    
    [[https://github.com/jtbm37/all-the-icons-dired][Git repository]]
    #+begin_src emacs-lisp
      (use-package all-the-icons-dired
        :after dired
        :hook
        (dired-mode . all-the-icons-dired-mode))
    #+end_src
    
*** Writable Dired
    Configuration for =wdired-mode=.
    #+begin_src emacs-lisp
      (use-package wdired
        :straight (:type built-in)
        :after dired
        :init
        (setq wdired-allow-to-change-permissions t)
        (setq wdired-create-parent-directories t))
    #+end_src
    
** Gnus
   Built-in package for managing RSS feeds, news and mail. For now I
   only use it for mail.  I'm using two GMail accounts here, each with
   authentication info in my =.authinfo= file.  In each account it's
   necessary to enable IMAP and either grant access to third party
   apps or create an app password and use that in =.authinfo=. Other
   than that, I have the variables =NAME= and =EMAIL= set in my =.profile=.
   
   I definitely still have things I want to improve on it, so that's
   coming soon. Either that or giving =mu4e= another try.

   [[https://www.emacswiki.org/emacs/GnusTutorial][EmacsWiki Gnus Tutorial]]
   #+begin_src emacs-lisp
     (use-package gnus
       :commands (gnus
                  compose-mail
                  compose-mail-other-window)
       :config
       (setq gnus-expert-user t)
       (setq gnus-select-method '(nnnil ""))
       (setq gnus-secondary-select-methods '((nnimap "uni"
                                                     (nnimap-address "imap.gmail.com")
                                                     (nnimap-server-port 993)
                                                     (nnimap-stream ssl)
                                                     (nnimap-authinfo-file "~/.authinfo"))
                                             (nnimap "personal"
                                                     (nnimap-address "imap.gmail.com")
                                                     (nnimap-server-port 993)
                                                     (nnimap-stream ssl)
                                                     (nnimap-authinfo-file "~/.authinfo"))))
       (setq message-send-mail-function 'smtpmail-send-it
             smtpmail-default-smtp-server "smtp.gmail.com")
       (luc/leader-def
         "ml" 'gnus
         "mc" 'compose-mail
         "mC" 'compose-mail-other-window))
   #+end_src

** Straight
   Some keybindings for accessing =straight.el= commands. The
   interactive =straight-use-package= now serves as my command to try
   out packages.
   #+begin_src emacs-lisp
     (use-package straight
       :init
       (luc/leader-def
         "ss" 'straight-use-package
         "sp" 'straight-pull-package
         "sP" 'straight-pull-all))
   #+end_src
   
** Terminal & Shell
*** Shell & shell commands
    I really like using =shell= if I don't need actual terminal
    emulation, because it really is just an Emacs buffer, with all the
    editing power I could want.
    
    I also want to be able to simply evaluate a command through the
    shell without having to pull up the buffer, so here I make leader
    keybindings for =shell-command= and =async-shell-command=.
    #+begin_src emacs-lisp
      (use-package shell
        :commands shell
        :init
        (luc/leader-def
          "as" 'shell
          "gs" 'shell-command
          "ga" 'async-shell-command))
    #+end_src
    
*** Vterm
    A very good terminal emulator for using inside Emacs. With
    =evil-collection=, it gets a lot more comfortable to use (still not
    as comfortable as the Emacs buffer that =shell= provides, but more
    comfortable nonetheless), and I especially like that it can toggle
    sending =ESC= to Emacs or the shell.
    
    [[https://github.com/akermu/emacs-libvterm][Git repository]]
    #+begin_src emacs-lisp
      (use-package vterm
        :init
        (evil-set-initial-state 'vterm-mode 'insert)
        (luc/leader-def
          "at" 'vterm)
        :commands vterm
        :config
        (evil-collection-vterm-setup)
        (general-def
          :keymaps 'vterm-mode-map
          :states 'insert
          "C-h" 'vterm--self-insert
          "C-l" 'vterm--self-insert
          "C-e" 'evil-scroll-line-down
          "C-y" 'evil-scroll-line-up
          "C-j" 'evil-collection-vterm-toggle-send-escape))
    #+end_src
    
** Hydra
   A package for grouping quick bindings together for a particular
   task. It's a lot easier to understand just seeing an example.
   
   [[https://github.com/abo-abo/hydra][Git repository]]
*** Scaling windows
    Scaling with =[count] C-w [+/-/</>]= doesn't feel very comfortable,
    since I never know exactly how much I want to scale. This hydra
    makes that a lot easier.
    #+begin_src emacs-lisp
      ;; With this, I can press 'SPC es' and then h/j/k/l how many
      ;; times I need to scale the window properly, then 'q' to quit.
      (use-package hydra
        :config
        (defhydra luc/hydra-window-scale ()
          "Scale current window."
          ("h" evil-window-decrease-width "width--")
          ("l" evil-window-increase-width "width++")
          ("j" evil-window-decrease-height "height--")
          ("k" evil-window-increase-height "height++")
          ("q" nil "quit" :exit t))
        (luc/leader-def
          "es" 'luc/hydra-window-scale/body))
    #+end_src
    
** Ispell & Flyspell
   =ispell= is a built-in spellchecking package, and =flyspell-mode= is
   used to highlight misspelled words. I had to install =aspell-en=
   (there are different =aspell= packages for other languages, at least
   in the Arch repositories) for it to work properly, but once that's
   done, it's done!
   #+begin_src emacs-lisp
     (use-package flyspell
       :hook
       (outline-mode . flyspell-mode)
       (text-mode . flyspell-mode)
       :config
       (general-def
         :states 'normal
         "z;" 'flyspell-auto-correct-word)
       (luc/leader-def
         "is" 'flyspell-buffer
         "if" 'flyspell-mode
         "id" 'ispell-change-dictionary))
   #+end_src
   
** PDF Tools
   My use for this so far have been simply reading PDF files, and it
   works very well.
   
   [[https://github.com/politza/pdf-tools][Git repository]]
   #+begin_src emacs-lisp
     (use-package pdf-tools
       :magic ("%PDF" . pdf-view-mode)
       :hook
       (pdf-view-mode . (lambda () (pdf-view-fit-page-to-window)))
       :config
       (pdf-tools-install
         :no-query t))
   #+end_src
   
** Keycast
   Display key combinations pressed and the command those are bound to
   execute in the modeline. Since I'm using =doom-modeline=, I looked
   for configuration to make it work properly and found this code
   [[https://www.emacswiki.org/emacs/KeyCast][here]].
   
   [[https://github.com/tarsius/keycast][Git repository]]
   #+begin_src emacs-lisp
     (use-package keycast
       :config
       (define-minor-mode luc/keycast-mode
         "Show current command and its key binding in the mode line (working on doom-modeline)."
         :global t
         (if luc/keycast-mode
             (add-hook 'pre-command-hook 'keycast--update t)
           (remove-hook 'pre-command-hook 'keycast--update)))
       (add-to-list 'global-mode-string '("" mode-line-keycast " "))
       (luc/keycast-mode))
   #+end_src
   
** Sudo Edit
   For editing files as the super user.
   #+begin_src emacs-lisp
     (use-package sudo-edit
       :commands sudo-edit
       :init
       (luc/leader-def
         "gS" 'sudo-edit))
   #+end_src
   
* Org Mode
  An amazing organization tool. I'm using it to write this very file,
  which really facilitates checking and updating the configuration,
  but there's a lot more to it as well.
   
  [[https://orgmode.org/manual/][Org Manual]]
** Preferences
   Changing the look and feel of =org-mode=, for maximum organization
   power.
*** Header Font Sizes
    #+begin_src emacs-lisp
      (use-package org
        :config
        (dolist (face '((org-level-1 . 1.1)
                        (org-level-2 . 1.05)
                        (org-level-3 . 1.0)
                        (org-level-4 . 1.0)
                        (org-level-5 . 1.0)
                        (org-level-6 . 1.0)
                        (org-level-7 . 1.0)
                        (org-level-8 . 1.0)))
          (set-face-attribute (car face) nil :height (cdr face))))
    #+end_src
     
*** Variable Pitch Mode 
    Different font pitches for different contexts.
    #+begin_src emacs-lisp
      (use-package org
        :config
        (defun luc/set-my-face-attributes ()
          (set-face-attribute 'fixed-pitch nil :font "UbuntuMono-13")
          (set-face-attribute 'default nil :inherit 'fixed-pitch)
          (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
          (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
          (set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)
          (set-face-attribute 'org-meta-line nil :inherit 'fixed-pitch))
        :hook
        (org-mode . luc/set-my-face-attributes)
        (org-mode . variable-pitch-mode))
    #+end_src
     
*** Ellipsis & Org Bullets
    Header markers are bullets and expansion markers are little
    triangles. A lot cleaner.
    #+begin_src emacs-lisp
      (use-package org
        :config
        (setq org-ellipsis " ▾")
        (use-package
          org-bullets
          :custom
          (org-bullets-bullet-list '("◉" "●" "○" "●" "○" "●" "○"))
          :hook (org-mode . org-bullets-mode)))
        #+end_src
     
*** Visual Line Mode
    For visual line wrapping at words.
    #+begin_src emacs-lisp
      (use-package org
        :hook (org-mode . visual-line-mode))
    #+end_src
     
*** Visual Fill Column
    For centering text in the buffer.
     
    [[https://github.com/joostkremers/visual-fill-column][Git repository]]
    #+begin_src emacs-lisp
      (use-package visual-fill-column
        :init
        (setq visual-fill-column-width 100)
        (setq visual-fill-column-center-text 1)
        :hook
        (org-mode . visual-fill-column-mode))
    #+end_src
     
*** Variables
    #+begin_src emacs-lisp
      (use-package org
        :init
        ;; For expanding blocks from snippets.
        (require 'org-tempo)
        ;; Headers are folded by default.
        (setq org-startup-folded t)
        ;; Indentation adapts to subtree level.
        (setq org-adapt-indentation t)
        ;; Hide markers for bold, italis, verbatim...
        (setq org-hide-emphasis-markers t))
    #+end_src
     
** Evil Org
   More Evil keybindings for Org Mode.
    
   [[https://github.com/Somelauw/evil-org-mode][Git repository]]
   #+begin_src emacs-lisp
     (use-package evil-org
       :after org
       :hook ((org-mode . evil-org-mode)
              (evil-org-mode . (lambda () (evil-org-set-key-theme '(navigation
                                                                    insert))))))
   #+end_src

** Exporting: Ox-Reveal and Htmlize
   Org is pretty easy to export to different formats (by default, =C-c
   C-e= will bring up Org Export Dispatcher with many options). For
   better visualization in HTML (including =reveal.js= presentations),
   these packages really come in handy.
    
   [[https://github.com/hexmode/ox-reveal][Ox Reveal]]
    
   [[https://github.com/hniksic/emacs-htmlize][Htmlize]]
   #+begin_src emacs-lisp
     (use-package ox-reveal
       :init
       (setq org-reveal-mathjax t))

     (use-package htmlize
       :commands htmlize-file)
   #+end_src

** Org Agenda
   I use this daily to manage my schedule, check deadlines, remember
   dates and keep track of my daily routine. Thankfully =evil-org= can
   bring more Evil keybindings to it as well.
    
   There's a keybinding for toggling =log-mode= in the agenda because
   repeated tasks (from the daily routine, for example) only show up
   there when I mark them as =DONE=, along with the timestamp for when
   I completed them.
   #+begin_src emacs-lisp
     (use-package org
       :hook
       (org-agenda-mode . hl-line-mode)
       :config
       (setq org-directory "~/storage/org")
       (setq org-agenda-files '("~/storage/org/agenda"))
       (setq org-agenda-log-mode-items '(closed clock state))
       (use-package evil-org-agenda
         :straight nil
         :config
         (evil-org-agenda-set-keys))
       (general-def
         :states 'motion
         :keymaps 'org-agenda-mode-map
         "w" 'org-save-all-org-buffers
         "l" 'org-agenda-log-mode)
       (luc/leader-def
         "ca" 'org-agenda))
   #+end_src
    
** Org Capture
   For quickly 'capturing' something in Org files. I mostly use it
   for adding items to the agenda, but have templates for other uses
   as well.
   #+begin_src emacs-lisp
     (use-package org
       :config
       (luc/leader-def
         "cc" 'org-capture)
       (setq org-capture-templates
             '(("d"
                "Task with deadline"
                entry (file+headline "agenda/deadlines.org" "Deadlines")
                "* TODO %^{Task}\nSCHEDULED: %^t DEADLINE: %^t")
               ("t"
                "Task without deadline"
                entry (file+headline "agenda/tasks.org" "Tasks")
                "* TODO %^{Task}\n SCHEDULED: %^t\n%?")
               ;; Saving events and dates as deadlines to get an early
               ;; reminder that they're coming.
               ("e"
                "Event"
                entry (file+headline "agenda/events.org" "Events")
                "* %^{Event}\nDEADLINE: %^T\n")
               ("r"
                "Dates to remember"
                entry (file+headline "agenda/dates.org" "Dates")
                "* %^{Description}\n%DEADLINE: ^t\n")
               ("l"
                "Link"
                entry (file+headline "links.org" "Links")
                "* [[%x][%^{Description}]]\n%U")
               ("i"
                "Idea/thought"
                entry (file+headline "thoughts.org" "Ideas & Thoughts")
                "* %?\n%U"))))
   #+end_src
    
** Org Babel
   For managing code blocks in Org files.
*** Automatic tangling
    =org-babel-tangle= writes the contents of the source blocks of an
    Org file into a destination file. Since I'm using it to write to
    configuration files, I'd like that function to be called every
    time I save the corresponding Org file.

    Here I make it so =org-babel-tangle= is added to the
    =after-save-hook= on Org files that match my specification. For
    that, I create a variable that holds a list of my Org
    configuration files (so far only this one) and a function to make
    the check.
    #+begin_src emacs-lisp
      (use-package emacs
        :config
        (defvar luc/org-config-dir (expand-file-name "~/dotfiles")
          "Directory containing org files to be tangled to automatically.")
       
        (defun luc/auto-tangle-config-files ()
          "Tangle the current org file, if in `luc/org-config-dir'."
          (when (member (buffer-file-name)
                        (directory-files-recursively luc/org-config-dir "\.org$"))
            (let ((org-confirm-babel-evaluate nil))
              (org-babel-tangle))))
       
        (use-package org
          :hook
          (org-mode . (lambda () (add-hook 'after-save-hook #'luc/auto-tangle-config-files)))))
    #+end_src
     
*** Languages
    Specifying the languages Org Babel should be able to execute and
    get results from in code blocks.
    #+begin_src emacs-lisp
      (use-package org
        :init
        (org-babel-do-load-languages
         'org-babel-load-languages '((python . t)
                                     (shell . t))))
    #+end_src
     
** Org Roam
   A very interesting tool for managing notes in Org Mode, creating a
   database of links between them. I just started playing around with
   it, and definitely recommend reading about it, it's pretty
   impressive - hope I can make the most of it.

   [[https://github.com/org-roam/org-roam][Git repository]]
   #+begin_src emacs-lisp
     (use-package org-roam
       :init
       (setq org-roam-v2-ack t)
       (setq org-roam-directory (concat org-directory "/roam"))
       (setq org-roam-dailies-directory "daily")
       (setq org-roam-dailies-capture-templates 
             '(("d" "default" entry
                "* %<%H:%M>\n%?"
                :if-new (file+head "%<%Y-%m-%d>.org"
                                   "#+title: %<%A, %d %B %Y>\n#+filetags: :journal:\n\n"))))
       :config
       (org-roam-setup)
       (general-def
         :states 'insert
         :keymaps 'org-mode-map
         "C-c i" 'org-roam-node-insert)
       (luc/leader-def
         "cn" 'org-roam-dailies-goto-next-note
         "cp" 'org-roam-dailies-goto-previous-note
         "cf" 'org-roam-node-find
         "cv" 'org-roam-capture
         "cx" 'org-roam-ref-add
         "cX" 'org-roam-ref-remove
         "cg" 'org-roam-tag-add
         "cG" 'org-roam-tag-remove
         "cl" 'org-roam-alias-add
         "cL" 'org-roam-alias-remove
         "cb" 'org-roam-buffer-toggle
         "ct" 'org-roam-dailies-goto-today
         "cT" 'org-roam-dailies-capture-today
         "cd" 'org-roam-dailies-goto-date
         "cD" 'org-roam-dailies-capture-date))
   #+end_src
    
* Development
  Building a comfy and powerful development environment.
** LSP & DAP Setup
   Language Server and Debug Adapter protocols. These will be used by
   different languages in different ways, which will be configured in
   [[*Languages][Languages]], so this is only a base setup. Fortunately, neither this
   or the specific setups are hard to get working properly. Here I'm
   also installing [[https://www.flycheck.org/][Flycheck]] so I can use it as my syntax checker (in
   place of =flymake=).
*** LSP Mode
    [[https://emacs-lsp.github.io/lsp-mode/][Overview]]
    #+begin_src emacs-lisp
      (use-package lsp-mode
        :commands (lsp lsp-deferred)
        :init
        (use-package flycheck ;; Syntax checker
          :config
          (use-package consult-flycheck)
          (luc/leader-def-for-keymaps
            :keymaps 'flycheck-mode-map
            "jc" 'consult-flycheck
            "je" 'flycheck-list-errors
            "jp" 'flycheck-previous-error
            "jn" 'flycheck-next-error))
        (luc/leader-def-for-keymaps
          :keymaps 'lsp-mode-map
          "ja" 'lsp-execute-code-action
          "jd" 'lsp-find-declaration
          "jr" 'lsp-rename
          "jf" 'lsp-find-references))
    #+end_src
   
*** LSP UI
    #+begin_src emacs-lisp
      (use-package lsp-ui
        :after lsp-mode
        :hook
        (lsp-mode . lsp-ui-mode)
        :init
        (setq lsp-ui-sideline-show-code-actions t)
        (setq lsp-ui-sideline-show-symbol t)
        (setq lsp-ui-sideline-show-diagnostics t)
        (luc/leader-def-for-keymaps
          :keymaps 'lsp-mode-map
          "ls" 'lsp-ui-sideline-mode))
    #+end_src
    
*** DAP Mode
    [[https://github.com/emacs-lsp/dap-mode][Git repository]]
    #+begin_src emacs-lisp
      (use-package dap-mode
        :hook
        ((lsp-mode . dap-mode)
         (dap-mode . dap-ui-mode)))
    #+end_src
    
** Languages
   Configuring the development environment for different languages
   (mainly with LSP and DAP).
*** Emacs Lisp
    So far, only a package to highlight quoted symbols, makes a lot of
    sense to me. Looking forward to expanding this section.
    
    [[https://github.com/Fanael/highlight-quoted][Highlight Quoted]]
    #+begin_src emacs-lisp
      (use-package highlight-quoted
        :hook
        (emacs-lisp-mode . highlight-quoted-mode)
        (lisp-interaction-mode . highlight-quoted-mode))
    #+end_src
    
*** C/C++
    Using =clangd=, which is looked for by default. For reference:
    [[https://emacs-lsp.github.io/lsp-mode/page/lsp-clangd/]]
    #+begin_src emacs-lisp
      (use-package cpp
        :hook ((c-mode c++-mode) . lsp-deferred))
    #+end_src
    
*** Python
    Using =pylsp=, which is looked for by default. For reference:
    https://emacs-lsp.github.io/lsp-mode/page/lsp-pylsp/    
    #+begin_src emacs-lisp
      (use-package python
        :hook (python-mode . lsp-deferred))
    #+end_src
    
*** Java
    #+begin_src emacs-lisp
      (use-package lsp-java
        :hook
        (java-mode . lsp))
    #+end_src
    
** Magit & Forge
   =magit= is an amazingly powerful Git front-end. I hadn't known of it
   before, but =forge= allows for working with Git forges (in my case,
   Github) from inside Emacs. Even more awesome!
   
   [[https://magit.vc/][Magit Website]]
   
   [[https://magit.vc/manual/forge/][Forge Manual]]
   #+begin_src emacs-lisp
     (use-package magit
       :commands (magit-status magit-clone)
       :init
       (luc/leader-def
         "am" 'magit-status
         "ay" 'magit-clone))
       :config
       (use-package forge
         :custom-face
         ;; For correcting error "Invalid face box".
         (forge-topic-label ((t :box (:line-width -1 :style released-button)))))
   #+end_src

